import { SceneKeys } from '../core/SceneKeys.js';\nimport { InputManager } from '../core/Input.js';\nimport { SaveManager } from '../core/SaveManager.js';\nimport { generateRoom, generateBarricades } from '../systems/ProceduralGen.js';\nimport { createEnemy, createShooterEnemy, createRunnerEnemy, createSniperEnemy, createMachineGunnerEnemy, createRocketeerEnemy, createBoss, createGrenadierEnemy, createPrismEnemy, createSnitchEnemy, createRookEnemy } from '../systems/EnemyFactory.js';\nimport { weaponDefs } from '../core/Weapons.js';\nimport { impactBurst, bitSpawnRing, pulseSpark, muzzleFlash, muzzleFlashSplit, ensureCircleParticle, ensurePixelParticle, pixelSparks, spawnDeathVfxForEnemy } from '../systems/Effects.js';\nimport { getEffectiveWeapon, getPlayerEffects } from '../core/Loadout.js';\nimport { buildNavGrid, worldToGrid, findPath } from '../systems/Pathfinding.js';\nimport { preloadWeaponAssets, createPlayerWeaponSprite, syncWeaponTexture, updateWeaponSprite, createFittedImage, getWeaponMuzzleWorld, getWeaponBarrelPoint } from '../systems/WeaponVisuals.js';\nimport { drawPanel } from '../ui/Panels.js';\nimport { makeTextButton } from '../ui/Buttons.js';\n\nconst DISABLE_WALLS = true; // Temporary: remove concrete walls\n\nexport default class CombatScene extends Phaser.Scene {\n  constructor() { super(SceneKeys.Combat); }\n  preload() {\n    // Ensure weapon images are loaded even if entering this scene directly\n    try { preloadWeaponAssets(this); } catch (_) {}\n  }\n  \n  openTerminalPanel() {\n    if (this.panel) return;\n    const { width } = this.scale;\n    const panelW = 360; const panelH = 300;\n    this.panel = drawPanel(this, width / 2 - panelW / 2, 60, panelW, panelH);\n    this.panel._type = 'terminal';\n    const title = this.add.text(width / 2, 80, 'Terminal - Spawn', { fontFamily: 'monospace', fontSize: 16, color: '#ffffff' }).setOrigin(0.5);\n    const y0 = 105; const line = 26; const cx = width / 2;\n    const addBtn = (ix, label, fn) => makeTextButton(this, cx, y0 + ix * line, label, fn);\n    const sp = (fn) => {\n      const px = this.player.x + Phaser.Math.Between(-40, 40);\n      const py = this.player.y + Phaser.Math.Between(-40, 40);\n      return fn(this, px, py);\n    };\n    const b1 = addBtn(0, 'Spawn Melee', () => { this.enemies.add(sp(createEnemy)); });\n    const b2 = addBtn(1, 'Spawn Runner', () => { this.enemies.add(sp(createRunnerEnemy)); });\n    const b3 = addBtn(2, 'Spawn Shooter', () => { this.enemies.add(sp(createShooterEnemy)); });\n    const b4 = addBtn(3, 'Spawn MachineGunner', () => { this.enemies.add(sp(createMachineGunnerEnemy)); });\n    const b5 = addBtn(4, 'Spawn Rocketeer', () => { this.enemies.add(sp(createRocketeerEnemy)); });\n    const b6 = addBtn(5, 'Spawn Sniper', () => { this.enemies.add(sp(createSniperEnemy)); });\n    const b7 = addBtn(6, 'Spawn Grenadier', () => { this.enemies.add(sp(createGrenadierEnemy)); });\n    const b8 = addBtn(7, 'Spawn Prism', () => { this.enemies.add(sp(createPrismEnemy)); });\n    const b9 = addBtn(8, 'Spawn Snitch', () => { this.enemies.add(sp(createSnitchEnemy)); });\n    const b10 = addBtn(9, 'Spawn Rook', () => { this.enemies.add(sp(createRookEnemy)); });\n    const b11 = addBtn(11, 'Spawn Boss', () => { this.enemies.add(sp((sc, x, y) => { const e = createBoss(sc, x, y, 600, 20, 50); e.isEnemy = true; return e; })); });\n    const b12 = addBtn(13, 'Clear Enemies', () => {\n      try { this.enemies.getChildren().forEach((e) => { if (e && e.active && !e.isDummy) e.destroy(); }); } catch (_) {}\n    });\n    const close = makeTextButton(this, cx, y0 + 15 * line, 'Close', () => this.closePanel([title, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, close]));\n    this.panel._extra = [title, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, close];\n  }\n\n  closePanel(extra = []) {\n    const extras = [\n      ...(Array.isArray(extra) ? extra : []),\n      ...(this.panel && Array.isArray(this.panel._extra) ? this.panel._extra : []),\n    ];\n    if (this.panel) { try { this.panel.destroy(); } catch (_) {} this.panel = null; }\n    extras.forEach((o) => { try { o?.destroy?.(); } catch (_) {} });\n  }\n\n  // Player melee implementation: 150鎺?cone, 48px range, 10 damage\n  performPlayerMelee() {\n    const caster = this.player;\n    if (!caster) return;\n    const ptr = this.inputMgr.pointer;\n    const ang = Math.atan2(ptr.worldY - caster.y, ptr.worldX - caster.x);\n    const totalDeg = 150; const half = Phaser.Math.DegToRad(totalDeg / 2);\n    const range = 48;\n    this._meleeAlt = !this._meleeAlt;\n    // Simple transparent fan to indicate affected area (white)\n    try { this.spawnMeleeVfx(caster, ang, totalDeg, 120, 0xffffff, range, this._meleeAlt); } catch (_) {}\n    // Damage check against enemies (mid-swing ~60ms to match enemy timing)\n    try {\n      this.time.delayedCall(60, () => {\n        const enemies = this.enemies?.getChildren?.() || [];\n        enemies.forEach((e) => {\n          if (!e?.active || !e.isEnemy || !caster?.active) return;\n          const dx = e.x - caster.x; const dy = e.y - caster.y;\n          const d = Math.hypot(dx, dy) || 1;\n          const pad = (e.body?.halfWidth || 6);\n          if (d > (range + pad)) return;\n          const dir = Math.atan2(dy, dx);\n          const diff = Math.abs(Phaser.Math.Angle.Wrap(dir - ang));\n          if (diff <= half) {\n            if (e.isDummy) {\n              this._dummyDamage = (this._dummyDamage || 0) + 10;\n              // Show universal hit VFX for dummy in shooting range\n              try { impactBurst(this, e.x, e.y, { color: 0xffffff, size: 'small' }); } catch (_) {}\n            } else {\n              if (typeof e.hp !== 'number') e.hp = e.maxHp || 20;\n              e.hp -= 10;\n              if (e.hp <= 0) { try { this.killEnemy(e); } catch (_) {} }\n              // Universal melee hit VFX on enemy\n              try { impactBurst(this, e.x, e.y, { color: 0xffffff, size: 'small' }); } catch (_) {}\n            }\n          }\n        });\n      });\n    } catch (_) {}\n  }\n\n\n  // Centralized damage application that respects Energy Shield and overrun\n  applyPlayerDamage(amount) {\n    try {\n      const gs = this.gs; if (!gs) return;\n      const dmg = Math.max(0, Math.floor(amount || 0)); if (dmg <= 0) return;\n      let remaining = dmg;\n      const s = Math.max(0, Math.floor(gs.shield || 0));\n      const hadShield = s > 0;\n      if (s > 0) {\n        const absorbed = Math.min(s, remaining);\n        gs.shield = s - absorbed;\n        remaining -= absorbed;\n      }\n      if (remaining > 0) {\n        let allow = (gs.allowOverrun !== false);\n        try { const eff = getPlayerEffects(gs) || {}; if (hadShield && eff.preventShieldOverflow) allow = false; } catch (_) {}\n        if (allow) gs.hp = Math.max(0, (gs.hp | 0) - remaining);\n      }\n      gs.lastDamagedAt = this.time.now;\n    } catch (_) {}\n  }\n\n  // Shared melee VFX: simple transparent fan (sector) showing affected area; follows caster position\n  spawnMeleeVfx(caster, baseAngle, totalDeg, durationMs, color, range, altStart) {\n    try {\n      if (caster._meleeFan?.cleanup) { caster._meleeFan.cleanup(); }\n      else if (caster._meleeFan?.g) { caster._meleeFan.g.destroy(); }\n    } catch (_) {}\n    const g = this.add.graphics({ x: caster.x, y: caster.y });\n    try { g.setDepth(9000); } catch (_) {}\n    const half = Phaser.Math.DegToRad(totalDeg / 2);\n    const a1 = baseAngle - half;\n    const a2 = baseAngle + half;\n    const r = Math.max(1, Math.floor(range));\n    const col = (typeof color === 'number') ? color : 0xffffff;\n    const alpha = 0.22;\n    try {\n      g.fillStyle(col, alpha);\n      g.beginPath();\n      g.moveTo(0, 0);\n      g.arc(0, 0, r, a1, a2, false);\n      g.closePath();\n      g.fillPath();\n    } catch (_) {}\n    const onUpdate = () => { try { g.x = caster.x; g.y = caster.y; } catch (_) {} };\n    this.events.on('update', onUpdate, this);\n    const cleanupFan = () => { try { this.events.off('update', onUpdate, this); } catch (_) {} try { g.destroy(); } catch (_) {} caster._meleeFan = null; };\n    const dur = Math.max(1, (durationMs | 0) || 100);\n    const guardFan = this.time.delayedCall(dur, cleanupFan);\n    caster._meleeFan = { g, guard: guardFan, cleanup: cleanupFan };\n    // Remove any prior swinging line overlay if present (ensure listener removal)\n    try {\n      if (caster._meleeLine?.cleanup) { caster._meleeLine.cleanup(); }\n      else if (caster._meleeLine?.g) { caster._meleeLine.g.destroy(); }\n      caster._meleeLine = null;\n    } catch (_) {}\n\n    // Add a bright additive "beam" line that sweeps across the melee fan during the swing\n    try {\n      const beam = this.add.graphics({ x: caster.x, y: caster.y });\n      try { beam.setDepth?.(9500); } catch (_) {}\n      try { beam.setBlendMode?.(Phaser.BlendModes.ADD); } catch (_) {}\n      const start = altStart ? (baseAngle + half) : (baseAngle - half);\n      const end = altStart ? (baseAngle - half) : (baseAngle + half);\n      const startAt = this.time.now;\n      const endAt = startAt + dur;\n      const thick = Math.max(2, Math.floor(r * 0.08));\n      // Base-white accent near origin for readability on enemies (short segment)\n      let lastSparkAt = 0;\n      let lastBurstAt = 0;\n      let lastAng = start;\n      const updateBeam = () => {\n        try {\n          if (!caster?.active) { cleanupBeam(); return; }\n          // Follow caster\n          beam.x = caster.x; beam.y = caster.y;\n          const now = this.time.now;\n          const t = Phaser.Math.Clamp((now - startAt) / Math.max(1, dur), 0, 1);\n          // Linear interpolate angles (range is <= 180鎺? safe for lerp)\n          const cur = start + (end - start) * t;\n          const tipX = Math.cos(cur) * r;\n          const tipY = Math.sin(cur) * r;\n          beam.clear();\n          // Outer colored stroke\n          beam.lineStyle(thick, col, 0.95);\n          beam.beginPath(); beam.moveTo(0, 0); beam.lineTo(tipX, tipY); beam.strokePath();\n          // White base segment for the first ~1/3 of beam length\n          const baseFrac = 0.35;\n          beam.lineStyle(Math.max(1, thick - 1), 0xffffee, 0.98);\n          beam.beginPath(); beam.moveTo(0, 0); beam.lineTo(tipX * baseFrac, tipY * baseFrac); beam.strokePath();\n          // Inner core using the beam color for the rest\n          beam.lineStyle(Math.max(1, thick - 1), col, 0.95);\n          beam.beginPath(); beam.moveTo(0, 0); beam.lineTo(tipX * 0.85, tipY * 0.85); beam.strokePath();\n          // Tip bloom\n          beam.fillStyle(col, 0.85).fillCircle(tipX, tipY, Math.max(2, Math.floor(thick * 0.6)));\n\n          // Particle trail: follow beam tip and spray opposite to sweep movement direction\n          if (!lastSparkAt || (now - lastSparkAt > 14)) {\n            lastSparkAt = now;\n            const dAng = Phaser.Math.Angle.Wrap(cur - lastAng);\n            const sprayDir = cur + (dAng >= 0 ? -Math.PI / 2 : Math.PI / 2);\n            lastAng = cur;\n            try {\n              pixelSparks(this, caster.x + tipX, caster.y + tipY, {\n                angleRad: sprayDir,\n                count: 4,\n                spreadDeg: 28,\n                speedMin: 200,\n                speedMax: 360,\n                lifeMs: 230,\n                color: col,\n                size: 2,\n                alpha: 0.95,\n              });\n            } catch (_) {}\n          }\n          // Periodic mini-burst for extra intensity\n          if (!lastBurstAt || (now - lastBurstAt > 60)) {\n            lastBurstAt = now;\n            const dAng = Phaser.Math.Angle.Wrap(cur - lastAng);\n            const sprayDir = cur + (dAng >= 0 ? -Math.PI / 2 : Math.PI / 2);\n            try {\n              pixelSparks(this, caster.x + tipX, caster.y + tipY, {\n                angleRad: sprayDir,\n                count: 6,\n                spreadDeg: 36,\n                speedMin: 220,\n                speedMax: 380,\n                lifeMs: 260,\n                color: col,\n                size: 2,\n                alpha: 0.95,\n              });\n            } catch (_) {}\n          }\n\n          if (now >= endAt) { cleanupBeam(); return; }\n        } catch (_) {}\n      };\n      this.events.on('update', updateBeam, this);\n      const cleanupBeam = () => {\n        try { this.events.off('update', updateBeam, this); } catch (_) {}\n        try { this.tweens.killTweensOf(beam); } catch (_) {}\n        try { beam.clear(); beam.visible = false; } catch (_) {}\n        try { beam.destroy(); } catch (_) {}\n        try { if (caster && caster._meleeLine && caster._meleeLine.g === beam) caster._meleeLine = null; } catch (_) {}\n      };\n      // Store handle for potential early cleanup next swing\n      caster._meleeLine = { g: beam, cleanup: cleanupBeam };\n      // Safety guard in case scene stops updating\n      this.time.delayedCall(dur, cleanupBeam);\n    } catch (_) {}\n  }\n\n  create() {\n    const { width, height } = this.scale;\n    // Ensure physics world bounds match the visible area so enemies can't leave the screen\n    this.physics.world.setBounds(0, 0, width, height);\n    try { this.physics.world.setBoundsCollision(true, true, true, true); } catch (_) {}\n    // Ensure UI overlay is active during combat\n    this.scene.launch(SceneKeys.UI);\n    this.gs = this.registry.get('gameState');\n    this.gs = this.registry.get('gameState');\n    // Ensure shield is full on scene start\n    try {\n      if (typeof this.gs.shieldMax !== "number") this.gs.shieldMax = 20;\n      this.gs.shield = this.gs.shieldMax;\n    } catch (_) {}\n    this.inputMgr = new InputManager(this);\n\n    // Player\n    this.player = this.physics.add.sprite(width / 2, height / 2, 'player_square').setCollideWorldBounds(true);\n    this.player.setSize(12, 12);\n    this.player.iframesUntil = 0;\n    this.playerFacing = 0; // radians\n\n    // Visualize currently equipped weapon in the player's hands\n    try { createPlayerWeaponSprite(this); } catch (_) {}\n\n    // Dash state\n    this.dash = { active: false, until: 0, cooldownUntil: 0, vx: 0, vy: 0, charges: 0, regen: [] };\n    this.dash.charges = this.gs.dashMaxCharges;\n    this.registry.set('dashCharges', this.dash.charges);\n    this.registry.set('dashRegenProgress', 1);\n\n    // Ammo tracking per-weapon for this scene\n    this._lastActiveWeapon = this.gs.activeWeapon;\n    this.ammoByWeapon = {};\n    this.reload = { active: false, until: 0, duration: 0 };\n    const cap0 = this.getActiveMagCapacity();\n    this.ensureAmmoFor(this._lastActiveWeapon, cap0);\n    this.registry.set('ammoInMag', this.ammoByWeapon[this._lastActiveWeapon] ?? cap0);\n    this.registry.set('magSize', cap0);\n    this.registry.set('reloadActive', false);\n    // Persistent WASP BITS (armour)\n    this._wasps = [];\n    // Laser state\n    this.laser = { heat: 0, firing: false, overheat: false, startedAt: 0, coolDelayUntil: 0, g: null, lastTickAt: 0 };\n    // Persistent fire fields from MGL core\n    this._firefields = [];\n    this.registry.set('reloadProgress', 0);\n\n    // Keep weapon sprite updated every frame without touching existing update()\n    try {\n      this.events.on('update', () => {\n        // Update position/rotation\n        updateWeaponSprite(this);\n        // Always try to sync texture in case it finished loading after create\n        if (this.gs) syncWeaponTexture(this, this.gs.activeWeapon);\n        this._lastActiveWeapon = this.gs?.activeWeapon;\n        // Shield regeneration (regens even from 0 after a delay)\n        // Shield VFX: subtle blue ring when shield > 0; break animation on 0\n        try {\n          const gs = this.gs; if (!gs || !this.player) return;\n          const hasShield = (gs.shield || 0) > 0.0001;\n          if (hasShield) {\n            if (!this._shieldRingG || !this._shieldRingG.active) {\n              this._shieldRingG = this.add.graphics({ x: this.player.x, y: this.player.y });\n              try { this._shieldRingG.setDepth(8800); } catch (_) {}\n              try { this._shieldRingG.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n            }\n            const g = this._shieldRingG; g.clear();\n            const t = (this.time.now % 1000) / 1000;\n            const radius = 13 + Math.sin(t * Math.PI * 2) * 1.0; const s = Math.max(0, gs.shield || 0); const smax = Math.max(1e-6, gs.shieldMax || 0); const p = Math.max(0, Math.min(1, s / smax)); const alpha = (0.12 + 0.28 * p) + Math.sin(t * Math.PI * 2) * 0.04 * p;\n            g.lineStyle(3, 0x66ccff, 0.55 + 0.4 * p).strokeCircle(0, 0, radius);\n            g.lineStyle(2, 0x99ddff, 0.3 + 0.4 * p).strokeCircle(0, 0, Math.max(11, radius - 2.5));\n            try { g.setAlpha(alpha); } catch (_) {}\n            g.x = this.player.x; g.y = this.player.y;\n          } else {\n            if (this._shieldRingG) {\n              const old = this._shieldRingG; this._shieldRingG = null;\n              try {\n                this.tweens.add({ targets: old, alpha: 0, scale: 1.6, duration: 160, ease: 'Cubic.Out', onComplete: () => { try { old.destroy(); } catch (_) {} } });\n              } catch (_) { try { old.destroy(); } catch (_) {} }\n              try {\n                const cx = this.player.x, cy = this.player.y;\n                for (let i = 0; i < 18; i += 1) {\n                  const a = (i / 12) * Math.PI * 2 + Phaser.Math.FloatBetween(-0.05, 0.05);\n                  pixelSparks(this, cx, cy, { angleRad: a, count: 1, spreadDeg: 10, speedMin: 160, speedMax: 280, lifeMs: 220, color: 0x66ccff, size: 2, alpha: 0.95 });\n                }\n                const br = this.add.graphics({ x: cx, y: cy });\n                try { br.setDepth(8800); br.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n                br.lineStyle(3, 0x66ccff, 1.0).strokeCircle(0, 0, 12);\n                this.tweens.add({ targets: br, alpha: 0, scale: 2.0, duration: 220, ease: 'Cubic.Out', onComplete: () => { try { br.destroy(); } catch (_) {} } });\n              } catch (_) {}\n            }\n          }\n        } catch (_) {}\n        try {\n          const gs = this.gs; if (!gs) return;\n          const now = this.time.now;\n          const since = now - (gs.lastDamagedAt || 0);\n          if (since >= (gs.shieldRegenDelayMs || 4000) && (gs.shield || 0) < (gs.shieldMax || 0)) {\n            const dt = ((this.game?.loop?.delta) || 16) / 1000;\n            const inc = ((gs.shieldRegenPerSec || 0) + ((getPlayerEffects(this.gs)||{}).shieldRegenBonus || 0)) * dt;\n            gs.shield = Math.min((gs.shield || 0) + inc, (gs.shieldMax || 0));\n          }\n        } catch (_) {}\n      });\n    } catch (_) {}\n\n    // Bullets group (use Arcade.Image for proper pooling)\n    this.bullets = this.physics.add.group({\n      classType: Phaser.Physics.Arcade.Image,\n      maxSize: 256,\n      runChildUpdate: true,\n    });\n\n    // Enemies (must be a physics group so overlaps work reliably)\n    this.enemies = this.physics.add.group();\n    const mods = this.gs.getDifficultyMods();\n    const room = generateRoom(this.gs.rng, this.gs.currentDepth);\n    this.room = room;\n    if (!DISABLE_WALLS) {\n      this.createArenaWalls(room);\n    } else {\n      // Expand arena to full screen when walls are disabled\n      const { width, height } = this.scale;\n      this.arenaRect = new Phaser.Geom.Rectangle(0, 0, width, height);\n      this.walls = null;\n    }\n    // Barricades: indestructible (hard) and destructible (soft)\n    this.barricadesHard = this.physics.add.staticGroup();\n    this.barricadesSoft = this.physics.add.staticGroup();\n    if (!this.gs?.shootingRange) {\n      // Choose a barricade variant for normal rooms\n      const brRoll = this.gs.rng.next();\n      const variant = (brRoll < 0.34) ? 'normal' : (brRoll < 0.67) ? 'soft_many' : 'hard_sparse';\n      const barricades = generateBarricades(this.gs.rng, this.arenaRect, variant);\n      barricades.forEach((b) => {\n        if (b.kind === 'hard') {\n          const s = this.physics.add.staticImage(b.x, b.y, 'barricade_hard');\n          s.setData('destructible', false);\n          this.barricadesHard.add(s);\n        } else {\n          const s = this.physics.add.staticImage(b.x, b.y, 'barricade_soft');\n          s.setData('destructible', true);\n          // Base HP for destructible tiles\n          s.setData('hp', 20);\n          this.barricadesSoft.add(s);\n        }\n      });\n    }\n    // Helper: pick a spawn on screen edges/corners, far from player\n    const pickEdgeSpawn = () => {\n      const pad = 12;\n      const { width: W, height: H } = this.scale;\n      const px = this.player.x, py = this.player.y;\n      const minDist = 180;\n      for (let tries = 0; tries < 12; tries += 1) {\n        const r = Math.random();\n        let sx = pad, sy = pad;\n        if (r < 0.125) { sx = pad; sy = pad; } // TL corner\n        else if (r < 0.25) { sx = W - pad; sy = pad; } // TR\n        else if (r < 0.375) { sx = pad; sy = H - pad; } // BL\n        else if (r < 0.5) { sx = W - pad; sy = H - pad; } // BR\n        else if (r < 0.625) { sx = Phaser.Math.Between(pad, W - pad); sy = pad; } // top\n        else if (r < 0.75) { sx = Phaser.Math.Between(pad, W - pad); sy = H - pad; } // bottom\n        else if (r < 0.875) { sx = pad; sy = Phaser.Math.Between(pad, H - pad); } // left\n        else { sx = W - pad; sy = Phaser.Math.Between(pad, H - pad); } // right\n        const dx = sx - px, dy = sy - py;\n        if ((dx * dx + dy * dy) >= (minDist * minDist)) return { x: sx, y: sy };\n      }\n      // Fallback: farthest corner from player\n      const sx = (px < this.scale.width / 2) ? (this.scale.width - pad) : pad;\n      const sy = (py < this.scale.height / 2) ? (this.scale.height - pad) : pad;\n      return { x: sx, y: sy };\n    };\n\n    if (!this.gs?.shootingRange) room.spawnPoints.forEach((_) => {\n      const sp = pickEdgeSpawn();\n      // Spawn composition (normal level): Sniper 10%, Shooter 20%, MachineGunner 10%, Rocketeer 10%, Runner 20%, Melee 30%\n      const roll = this.gs.rng.next();\n      let e;\n      if (roll < 0.10) {\n        e = createSniperEnemy(this, sp.x, sp.y, Math.floor(80 * mods.enemyHp), Math.floor(18 * mods.enemyDamage), 40);\n      } else if (roll < 0.30) {\n        e = createShooterEnemy(this, sp.x, sp.y, Math.floor(90 * mods.enemyHp), Math.floor(8 * mods.enemyDamage), 50, 900);\n      } else if (roll < 0.40) {\n        e = createMachineGunnerEnemy(this, sp.x, sp.y, Math.floor(140 * mods.enemyHp), Math.floor(7 * mods.enemyDamage), 35, 1100, 12, 24);\n      } else if (roll < 0.50) {\n        e = createRocketeerEnemy(this, sp.x, sp.y, Math.floor(80 * mods.enemyHp), Math.floor(12 * mods.enemyDamage), 40, 2000);\n      } else if (roll < 0.70) {\n        // Melee runner (fast)\n        const meleeDmg = Math.floor(Math.floor(10 * mods.enemyDamage) * 1.5); // +50% melee damage\n        e = createRunnerEnemy(this, sp.x, sp.y, Math.floor(60 * mods.enemyHp), meleeDmg, 120);\n      } else {\n        // Melee normal\n        const meleeDmg = Math.floor(Math.floor(10 * mods.enemyDamage) * 1.5); // +50% melee damage\n        e = createEnemy(this, sp.x, sp.y, Math.floor(100 * mods.enemyHp), meleeDmg, 60);\n      }\n      this.enemies.add(e);\n    });\n    // Elite: exactly 1 per room; split between Grenadier, Prism, Snitch, Rook\n    if (!this.gs?.shootingRange) {\n      const spE = pickEdgeSpawn();\n      const pick = Math.random(); // unseeded to avoid same choice every room\n      if (pick < (1/4)) {\n        const eG = createGrenadierEnemy(this, spE.x, spE.y, Math.floor(260 * mods.enemyHp), Math.floor(14 * mods.enemyDamage), 48, 2000);\n        this.enemies.add(eG);\n      } else if (pick < (2/4)) {\n        const eP = createPrismEnemy(this, spE.x, spE.y, Math.floor(180 * mods.enemyHp), Math.floor(16 * mods.enemyDamage), 46);\n        this.enemies.add(eP);\n      } else if (pick < (3/4)) {\n        const eS = createSnitchEnemy(this, spE.x, spE.y, Math.floor(100 * mods.enemyHp), Math.floor(6 * mods.enemyDamage), 60);\n        this.enemies.add(eS);\n      } else {\n        const eR = createRookEnemy(this, spE.x, spE.y, Math.floor(300 * mods.enemyHp), Math.floor(25 * mods.enemyDamage), 35);\n        this.enemies.add(eR);\n      }\n    }\n\n    // Shooting Range setup: terminal, dummy, and portal to hub\n    if (this.gs?.shootingRange) {\n      // Terminal (left side)\n      this.terminalZone = this.add.zone(60, height / 2, 36, 36);\n      this.physics.world.enable(this.terminalZone);\n      this.terminalZone.body.setAllowGravity(false);\n      this.terminalZone.body.setImmovable(true);\n      this.terminalG = this.add.graphics();\n      this.terminalG.fillStyle(0x33ccff, 1).fillRect(this.terminalZone.x - 12, this.terminalZone.y - 12, 24, 24);\n\n      // Persistent dummy target in the center-right\n      this._dummyDamage = 0;\n      this.dummy = this.physics.add.sprite(width / 2 + 120, height / 2, 'enemy_square');\n      this.dummy.setSize(12, 12).setOffset(0, 0).setCollideWorldBounds(true);\n      this.dummy.setTint(0xffff00);\n      this.dummy.isEnemy = true;\n      this.dummy.isDummy = true;\n      this.dummy.maxHp = 999999;\n      this.dummy.hp = this.dummy.maxHp;\n      this.enemies.add(this.dummy);\n      this.dummyLabel = this.add.text(this.dummy.x, this.dummy.y - 16, 'DMG: 0', { fontFamily: 'monospace', fontSize: 12, color: '#ffff66' }).setOrigin(0.5);\n\n      // Portal back to Hub (right side)\n      const px = width - 40; const py = height / 2;\n      this.portal = this.physics.add.staticImage(px, py, 'portal');\n      this.portal.setSize(24, 24).setOffset(0, 0);\n\n      // Helper text\n      this.rangeText = this.add.text(width / 2, 28, 'Shooting Range: E near Terminal/Dummy/Portal', { fontFamily: 'monospace', fontSize: 14, color: '#ffffff' }).setOrigin(0.5);\n    }\n\n    // Colliders\n    if (this.walls) {\n      this.physics.add.collider(this.player, this.walls);\n      this.physics.add.collider(this.enemies, this.walls);\n    }\n    // Colliders with barricades (block movement and bullets)\n    this.physics.add.collider(this.player, this.barricadesHard);\n    this.physics.add.collider(this.player, this.barricadesSoft);\n    this.physics.add.collider(this.enemies, this.barricadesHard);\n    this.physics.add.collider(this.enemies, this.barricadesSoft);\n    // Enemies can break destructible barricades by pushing into them\n    this.physics.add.collider(this.enemies, this.barricadesSoft, (e, s) => this.onEnemyHitBarricade(e, s));\n    // For rail bullets, skip physics separation so they don't get stuck\n    this.physics.add.collider(\n      this.bullets,\n      this.barricadesHard,\n      (b, s) => this.onBulletHitBarricade(b, s),\n      (b, s) => !(b && b._rail),\n      this,\n    );\n    this.physics.add.collider(\n      this.bullets,\n      this.barricadesSoft,\n      (b, s) => this.onBulletHitBarricade(b, s),\n      (b, s) => {\n        if (!b || !s) return false;\n        if (b._rail) return false; // rail pierces\n        if (b._core === 'pierce') {\n          try {\n            const dmg = (typeof b.damage === 'number' && b.damage > 0) ? b.damage : 10;\n            const hp0 = (typeof s.getData('hp') === 'number') ? s.getData('hp') : 20;\n            const hp1 = hp0 - dmg;\n            try { impactBurst(this, b.x, b.y, { color: 0xC8A165, size: 'small' }); } catch (_) {}\n            if (hp1 <= 0) { try { s.destroy(); } catch (_) {} } else { s.setData('hp', hp1); }\n          } catch (_) {}\n          return false;\n        }\n        return true;\n      },\n      this,\n    );\n\n    // Shield hitboxes for Rook (separate from body)\n    this.rookShieldGroup = this.physics.add.group();\n    this.physics.add.overlap(this.bullets, this.rookShieldGroup, (b, z) => {\n      try {\n        if (!b?.active || !z?.active) return;\n        if (b._rail) return; // rail pierces shields\n        const e = z._owner; if (!e?.active || !e.isRook) return;\n        const cx = z.x, cy = z.y; const r = (e._shieldRadius || 60);\n        const angToBullet = Math.atan2(b.y - cy, b.x - cx);\n        const shieldAng = e._shieldAngle || 0; const half = Phaser.Math.DegToRad(45);\n        const diff = Math.abs(Phaser.Math.Angle.Wrap(angToBullet - shieldAng));\n        if (diff <= half) {\n          const dxr = b.x - cx, dyr = b.y - cy; const d2 = dxr * dxr + dyr * dyr; const r2 = r * r;\n          if (d2 >= (r2 * 0.7)) {\n            const hitX = cx + Math.cos(angToBullet) * r;\n            const hitY = cy + Math.sin(angToBullet) * r;\n            try { impactBurst(this, hitX, hitY, { color: 0xff3333, size: 'small' }); } catch (_) {}\n            try { if (b.body) b.body.checkCollision.none = true; } catch (_) {}\n            try { b.setActive(false).setVisible(false); } catch (_) {}\n            this.time.delayedCall(0, () => { try { b.destroy(); } catch (_) {} });\n          }\n        }\n      } catch (_) {}\n    }, null, this);\n    // Rook shield zone overlap disabled; blocking handled in bullets vs enemies outer-arc check\n\n    this.physics.add.overlap(this.bullets, this.enemies, (b, e) => {\n      if (!b.active || !e.active) return;\n      // Rook shield: block non-rail bullets (including rockets) within 90掳 front arc\n      if (e.isRook && !b._rail) {\n        try {\n          const r = (e._shieldRadius || 60);\n          const gap = 35; const off = (gap - r);\n          const cx = e.x + Math.cos(e._shieldAngle || 0) * off;\n          const cy = e.y + Math.sin(e._shieldAngle || 0) * off;\n          const angToBullet = Math.atan2(b.y - cy, b.x - cx);\n          const shieldAng = e._shieldAngle || 0;\n          const diff = Math.abs(Phaser.Math.Angle.Wrap(angToBullet - shieldAng));\n          const half = Phaser.Math.DegToRad(45);\n          // r: using fixed shield radius above\n          // Compute hit on outside arc boundary along direction from shield center to bullet\n          const hitX = cx + Math.cos(angToBullet) * r;\n          const hitY = cy + Math.sin(angToBullet) * r;\n          // Only block if bullet is within arc sector and outside/at radius (ensures boundary hit)\n          const dxr = b.x - cx, dyr = b.y - cy; const d2 = dxr * dxr + dyr * dyr;\n          if (diff <= half && d2 >= (r * r * 0.9)) {\n            // Spark exactly on the arc boundary\n            try { impactBurst(this, hitX, hitY, { color: 0xff3333, size: 'small' }); } catch (_) {}\n            // Destroy projectile without applying damage or AoE\n            try { if (b.body) b.body.checkCollision.none = true; } catch (_) {}\n            try { b.setActive(false).setVisible(false); } catch (_) {}\n            this.time.delayedCall(0, () => { try { b.destroy(); } catch (_) {} });\n            return;\n          }\n        } catch (_) {}\n      }\n      // Only track per-target hits for piercing bullets to allow shotgun pellets to stack normally\n      if (b._core === 'pierce') {\n        if (!b._hitSet) b._hitSet = new Set();\n        if (b._hitSet.has(e)) return;\n        b._hitSet.add(e);\n      }\n      // Dummy target: accumulate damage and do not die\n      if (e.isDummy) {\n        const baseDmg = b.damage || 10;\n        const primaryDmg = (b._core === 'blast' && !b._rocket) ? Math.ceil(baseDmg * 0.8) : baseDmg;\n        this._dummyDamage = (this._dummyDamage || 0) + primaryDmg;\n        // Reflect on-hit status effects in Range: build ignite/toxin values on dummy\n        if (b._igniteOnHit && b._igniteOnHit > 0) {\n          e._igniteValue = Math.min(10, (e._igniteValue || 0) + b._igniteOnHit);\n          if ((e._igniteValue || 0) >= 10) {\n            e._ignitedUntil = this.time.now + 2000;\n            e._igniteValue = 0; // reset on trigger\n            // Create/position ignite indicator for dummy\n            if (!e._igniteIndicator) {\n              e._igniteIndicator = this.add.graphics();\n              try { e._igniteIndicator.setDepth(9000); } catch (_) {}\n              e._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2);\n            }\n            try { e._igniteIndicator.setPosition(e.x, e.y - 14); } catch (_) {}\n          }\n        }\n        if (b._toxinOnHit && b._toxinOnHit > 0) {\n          e._toxinValue = Math.min(10, (e._toxinValue || 0) + b._toxinOnHit);\n          if ((e._toxinValue || 0) >= 10) {\n            e._toxinedUntil = this.time.now + 2000;\n            e._toxinValue = 0; // reset on trigger\n            // Create/position toxin indicator for dummy\n            if (!e._toxinIndicator) {\n              e._toxinIndicator = this.add.graphics();\n              try { e._toxinIndicator.setDepth(9000); } catch (_) {}\n              e._toxinIndicator.fillStyle(0x33ff33, 1).fillCircle(0, 0, 2);\n            }\n            try { e._toxinIndicator.setPosition(e.x, e.y - 18); } catch (_) {}\n          }\n        }\n        if (b._stunOnHit && b._stunOnHit > 0) {\n          const nowS = this.time.now;\n          e._stunValue = Math.min(10, (e._stunValue || 0) + b._stunOnHit);\n          if ((e._stunValue || 0) >= 10) {\n            e._stunnedUntil = nowS + 200;\n            e._stunValue = 0;\n            if (!e._stunIndicator) { e._stunIndicator = this.add.graphics(); try { e._stunIndicator.setDepth(9000); } catch (_) {} e._stunIndicator.fillStyle(0xffff33, 1).fillCircle(0, 0, 2); }\n            try { e._stunIndicator.setPosition(e.x, e.y - 22); } catch (_) {}\n          }\n        }\n      } else {\n        if (typeof e.hp !== 'number') e.hp = e.maxHp || 20;\n        // Apply damage (Explosive Core reduces primary to 80%; explosive projectiles keep 100%)\n        {\n          const baseDmg = b.damage || 10;\n          const primaryDmg = (b._core === 'blast' && !b._rocket) ? Math.ceil(baseDmg * 0.8) : baseDmg;\n          e.hp -= primaryDmg;\n        }\n        // Apply ignite buildup from special cores (e.g., Rifle Incendiary)\n        if (b._igniteOnHit && b._igniteOnHit > 0) {\n          const add = b._igniteOnHit;\n          e._igniteValue = Math.min(10, (e._igniteValue || 0) + add);\n          if ((e._igniteValue || 0) >= 10) {\n            const nowT = this.time.now;\n            e._ignitedUntil = nowT + 2000;\n            e._igniteValue = 0; // reset on trigger\n            if (!e._igniteIndicator) {\n              e._igniteIndicator = this.add.graphics();\n              try { e._igniteIndicator.setDepth(9000); } catch (_) {}\n              e._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2);\n            }\n            try { e._igniteIndicator.setPosition(e.x, e.y - 14); } catch (_) {}\n          }\n        }\n        // Apply toxin buildup from special cores (e.g., SMG Toxic Rounds)\n        if (b._toxinOnHit && b._toxinOnHit > 0) {\n          const addT = b._toxinOnHit;\n          e._toxinValue = Math.min(10, (e._toxinValue || 0) + addT);\n          if ((e._toxinValue || 0) >= 10) {\n            const nowT = this.time.now;\n            e._toxinedUntil = nowT + 2000;\n            e._toxinValue = 0; // reset on trigger\n            if (!e._toxinIndicator) {\n              e._toxinIndicator = this.add.graphics();\n              try { e._toxinIndicator.setDepth(9000); } catch (_) {}\n              e._toxinIndicator.fillStyle(0x33ff33, 1).fillCircle(0, 0, 2);\n            }\n            try { e._toxinIndicator.setPosition(e.x, e.y - 18); } catch (_) {}\n          }\n        }\n        // Apply stun buildup from stun ammunition (normal enemies)\n        if (b._stunOnHit && b._stunOnHit > 0) {\n          const nowS = this.time.now;\n          e._stunValue = Math.min(10, (e._stunValue || 0) + b._stunOnHit);\n          if ((e._stunValue || 0) >= 10) {\n            e._stunnedUntil = nowS + 200;\n            e._stunValue = 0;\n            if (!e._stunIndicator) { e._stunIndicator = this.add.graphics(); try { e._stunIndicator.setDepth(9000); } catch (_) {} e._stunIndicator.fillStyle(0xffff33, 1).fillCircle(0, 0, 2); }\n            try { e._stunIndicator.setPosition(e.x, e.y - 22); } catch (_) {}\n          }\n        }\n      }\n      // Visual impact effect by core type (small unless blast)\n      try {\n        const core = b._core || null;\n        if (core === 'blast') {\n          const radius = b._blastRadius || 20;\n          impactBurst(this, b.x, b.y, { color: 0xffaa33, size: 'large', radius });\n        } else if (core === 'pierce') impactBurst(this, b.x, b.y, { color: 0x66aaff, size: 'small' });\n        else impactBurst(this, b.x, b.y, { color: 0xffffff, size: 'small' });\n      } catch (_) {}\n      // Apply blast splash before removing the bullet\n      if (b._core === 'blast') {\n        const radius = b._blastRadius || 20;\n        this.enemies.getChildren().forEach((other) => {\n          if (!other.active) return;\n          const isPrimary = (other === e);\n          if (isPrimary && !b._rocket) return; // do not double-hit primary for core-only blasts\n          const dx = other.x - b.x; const dy = other.y - b.y;\n          if (dx * dx + dy * dy <= radius * radius) {\n            const splashDmg = b._rocket ? (b._aoeDamage || b.damage || 10) : Math.ceil((b.damage || 10) * 0.5);\n            if (other.isDummy) {\n              this._dummyDamage = (this._dummyDamage || 0) + splashDmg;\n            } else {\n              if (typeof other.hp !== 'number') other.hp = other.maxHp || 20;\n              other.hp -= splashDmg;\n              if (other.hp <= 0) { this.killEnemy(other); }\n            }\n          }\n        });\n        // Splash to barricades now 100%\n        this.damageSoftBarricadesInRadius(b.x, b.y, radius, (b.damage || 10));\n        // Drop fire field on any explosive detonation, not just when reaching target\n        try {\n          if (b._firefield) {\n            this.spawnFireField(b.x, b.y, radius);\n            // Napalm: apply immediate ignite buildup (+5) to enemies in radius\n            const r2 = radius * radius; const nowT = this.time.now;\n            this.enemies.getChildren().forEach((other) => {\n              if (!other?.active || other.isDummy) return;\n              const dx2 = other.x - b.x; const dy2 = other.y - b.y;\n              if ((dx2 * dx2 + dy2 * dy2) <= r2) {\n                other._igniteValue = Math.min(10, (other._igniteValue || 0) + 5);\n                if ((other._igniteValue || 0) >= 10) {\n                  other._ignitedUntil = nowT + 2000; other._igniteValue = 0;\n                  if (!other._igniteIndicator) { other._igniteIndicator = this.add.graphics(); try { other._igniteIndicator.setDepth(9000); } catch (_) {} other._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2); }\n                  try { other._igniteIndicator.setPosition(other.x, other.y - 14); } catch (_) {}\n                }\n              }\n            });\n          }\n        } catch (_) {}\n      }\n      // Handle pierce core: allow one extra target without removing the bullet\n      if (b._core === 'pierce' && (b._pierceLeft || 0) > 0) {\n        b._pierceLeft -= 1;\n      } else {\n        // Defer removal to end of tick to avoid skipping other overlaps this frame\n        try { if (b.body) b.body.checkCollision.none = true; } catch (_) {}\n        try { b.setActive(false).setVisible(false); } catch (_) {}\n        this.time.delayedCall(0, () => { try { b.destroy(); } catch (_) {} });\n      }\n      // Check primary enemy death after damage\n      if (e.hp <= 0) { this.killEnemy(e); }\n    });\n\n    this.physics.add.overlap(this.player, this.enemies, (p, e) => {\n      // Ignore dummy collisions for player damage\n      if (e?.isDummy) return;\n      // Melee enemies do not apply touch damage; only their cone hit can damage\n      if (e?.isMelee) return;\n      if (this.time.now < this.player.iframesUntil) return;\n      this.applyPlayerDamage(e.damage);\n      this.player.iframesUntil = this.time.now + 600;\n      if (this.gs.hp <= 0) {\n        // For framework: respawn at hub\n        const eff = getPlayerEffects(this.gs);\n        this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n        this.gs.nextScene = SceneKeys.Hub;\n        SaveManager.saveToLocal(this.gs);\n        this.scene.start(SceneKeys.Hub);\n      }\n    });\n\n    // Enemy bullets (for shooters)\n    this.enemyBullets = this.physics.add.group({\n      classType: Phaser.Physics.Arcade.Image,\n      maxSize: 64,\n      runChildUpdate: true,\n    });\n    // Enemy grenades (for elite Grenadiers)\n    this.enemyGrenades = this.physics.add.group({\n      classType: Phaser.Physics.Arcade.Image,\n      maxSize: 24,\n      runChildUpdate: true,\n    });\n    // Grenades collide with barricades (respect cover)\n    this.physics.add.collider(this.enemyGrenades, this.barricadesHard, (b, s) => this.onEnemyGrenadeHitBarricade(b, s));\n    this.physics.add.collider(this.enemyGrenades, this.barricadesSoft, (b, s) => this.onEnemyGrenadeHitBarricade(b, s));\n    this.physics.add.overlap(this.player, this.enemyBullets, (p, b) => {\n      const inIframes = this.time.now < this.player.iframesUntil;\n      if (b?._rocket) {\n        // Rocket: explode on contact, apply AoE to player\n      const ex = b.x; const ey = b.y; const radius = b._blastRadius || 70; const r2 = radius * radius;\n        const pdx = this.player.x - ex; const pdy = this.player.y - ey;\n        if ((pdx * pdx + pdy * pdy) <= r2 && !inIframes) {\n          let dmg = (typeof b.damage === 'number' && b.damage > 0) ? b.damage : 12; try { const eff = getPlayerEffects(this.gs) || {}; const mul = eff.enemyExplosionDmgMul || 1; dmg = Math.ceil(dmg * mul); } catch (_) {} this.applyPlayerDamage(dmg);\n          this.player.iframesUntil = this.time.now + 600;\n          if (this.gs.hp <= 0) {\n            const eff = getPlayerEffects(this.gs);\n            this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n            this.gs.nextScene = SceneKeys.Hub;\n            SaveManager.saveToLocal(this.gs);\n            this.scene.start(SceneKeys.Hub);\n          }\n        }\n        try { impactBurst(this, ex, ey, { color: 0xff3333, size: 'large', radius }); } catch (_) {}\n        // Chip nearby destructible barricades\n        this.damageSoftBarricadesInRadius(ex, ey, radius, (b.damage || 12));\n        try { b.destroy(); } catch (_) {}\n        return;\n      }\n      if (!inIframes) {\n        const dmg = (typeof b.damage === 'number' && b.damage > 0) ? b.damage : 8; // default shooter damage\n        this.applyPlayerDamage(dmg);\n        this.player.iframesUntil = this.time.now + 600;\n        if (this.gs.hp <= 0) {\n          const eff = getPlayerEffects(this.gs);\n          this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n          this.gs.nextScene = SceneKeys.Hub;\n          SaveManager.saveToLocal(this.gs);\n          this.scene.start(SceneKeys.Hub);\n        }\n      }\n      // Always destroy enemy bullet on contact, even during i-frames\n      try { b.destroy(); } catch (_) {}\n    });\n    // Enemy bullets blocked by barricades as well\n    this.physics.add.collider(this.enemyBullets, this.barricadesHard, (b, s) => this.onEnemyBulletHitBarricade(b, s));\n    this.physics.add.collider(this.enemyBullets, this.barricadesSoft, (b, s) => this.onEnemyBulletHitBarricade(b, s));\n\n    // Exit appears when all enemies dead\n    this.exitActive = false;\n    this.exitG = this.add.graphics();\n    // Move in-game prompt down to avoid overlapping UI\n    this.prompt = this.add.text(width / 2, 40, 'Clear enemies', { fontFamily: 'monospace', fontSize: 14, color: '#ffffff' }).setOrigin(0.5);\n    // Keybinds hint (bottom-right, small font)\n    const binds = 'W/A/S/D: Move`nSpace: Dash`nE: Interact`nLMB: Shoot`nF: Ability`nQ: Swap Weapon`nTab: Loadout';\n\n    this.add.text(width - 10, height - 10, binds, { fontFamily: 'monospace', fontSize: 12, color: '#cccccc' })\n      .setOrigin(1, 1)\n      .setAlpha(0.9);\n\n    // Init nav state for enemy pathfinding\n    this._nav = { grid: null, builtAt: 0 };\n    // Ability system state (cooldown etc.)\n    this._gadgets = [];\n    this.ability = { onCooldownUntil: 0 };\n    \n  }\n\n  // Centralized enemy death handler to keep removal tied to HP system\n  killEnemy(e) {\n    if (!e || !e.active) return;\n    try {\n      // Ensure HP reflects death for any downstream logic\n      if (typeof e.hp === 'number' && e.hp > 0) e.hp = 0;\n    } catch (_) {}\n    try { if (e._igniteIndicator) { e._igniteIndicator.destroy(); e._igniteIndicator = null; } } catch (_) {}\n    try { if (e._toxinIndicator) { e._toxinIndicator.destroy(); e._toxinIndicator = null; } } catch (_) {}\n    // Grenadier: explode on death\n    try {\n      if (e.isGrenadier && !e._exploded) {\n        const ex = e.x; const ey = e.y; const radius = (e.explosionRadius || 60); // visual matches damage AoE\n        try { impactBurst(this, ex, ey, { color: 0xff3333, size: 'large', radius }); } catch (_) {}\n        // Damage player if within radius\n        const r2 = radius * radius; const pdx = this.player.x - ex; const pdy = this.player.y - ey;\n        if ((pdx * pdx + pdy * pdy) <= r2) {\n          const now = this.time.now;\n          if (now >= (this.player.iframesUntil || 0)) {\n            { let dmg=(e?.damage||14); try{ const eff=getPlayerEffects(this.gs)||{}; const mul=eff.enemyExplosionDmgMul||1; dmg=Math.ceil(dmg*mul);}catch(_){} this.applyPlayerDamage(dmg); }\n            this.player.iframesUntil = now + 600;\n            if (this.gs.hp <= 0) {\n              const eff = getPlayerEffects(this.gs);\n              this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n              this.gs.nextScene = SceneKeys.Hub;\n              SaveManager.saveToLocal(this.gs);\n              this.scene.start(SceneKeys.Hub);\n            }\n          }\n        }\n        // Also chip destructible barricades\n        this.damageSoftBarricadesInRadius(ex, ey, radius, (e.damage || 14));\n        e._exploded = true;\n      }\n    } catch (_) {}\n    // Reward gold per standard enemy kill\n    try { this.gs.gold += 5; } catch (_) {}\n    // Death VFX (purely visual)\n    try { spawnDeathVfxForEnemy(this, e); } catch (_) {}\n    // Destroy the enemy sprite\n    try { e.destroy(); } catch (_) {}\n  }\n\n  // Player bullet hits a barricade (hard or soft)\n  onBulletHitBarricade(b, s) {\n    if (!b || !b.active || !s) return;\n    // Railgun bullets pierce and do not affect barricades\n    if (b._rail) return;\n    const isSoft = !!s.getData('destructible');\n    const dmg = (typeof b.damage === 'number' && b.damage > 0) ? b.damage : 10;\n    // Apply damage to destructible tiles\n    if (isSoft) {\n      const hp0 = (typeof s.getData('hp') === 'number') ? s.getData('hp') : 20;\n      const hp1 = hp0 - dmg;\n      // Small brown puff for soft hits\n      try { impactBurst(this, b.x, b.y, { color: 0xC8A165, size: 'small' }); } catch (_) {}\n      if (hp1 <= 0) {\n        try { s.destroy(); } catch (_) {}\n      } else {\n        s.setData('hp', hp1);\n      }\n    } else {\n      // Grey puff on hard\n      try { impactBurst(this, b.x, b.y, { color: 0xBBBBBB, size: 'small' }); } catch (_) {}\n    }\n    // Rockets: explode on barricade contact and splash enemies\n    if (b._core === 'blast') {\n      const radius = b._blastRadius || 20;\n      try { impactBurst(this, b.x, b.y, { color: 0xffaa33, size: 'large', radius }); } catch (_) {}\n      const r2 = radius * radius; const ex = b.x; const ey = b.y;\n      this.enemies.getChildren().forEach((other) => {\n        if (!other?.active) return;\n        const dx = other.x - ex; const dy = other.y - ey;\n        if (dx * dx + dy * dy <= r2) {\n          const splashDmg = b._rocket ? (b._aoeDamage || b.damage || 10) : Math.ceil((b.damage || 10) * 0.5);\n          if (other.isDummy) {\n            this._dummyDamage = (this._dummyDamage || 0) + splashDmg;\n          } else {\n            if (typeof other.hp !== 'number') other.hp = other.maxHp || 20;\n            other.hp -= splashDmg;\n            if (other.hp <= 0) this.killEnemy(other);\n          }\n        }\n      });\n      // Also damage nearby destructible barricades\n      this.damageSoftBarricadesInRadius(ex, ey, radius, (b.damage || 10));\n      // Ensure fire field spawns on barricade detonation as well\n      try { if (b._firefield) this.spawnFireField(ex, ey, radius); } catch (_) {}\n    }\n    // Always destroy player bullet on barricade collision\n    try { b.destroy(); } catch (_) {}\n  }\n\n  // Enemy bullet hits a barricade\n  onEnemyBulletHitBarricade(b, s) {\n    if (!b || !s) return;\n    const isSoft = !!s.getData('destructible');\n    // Explosive rockets: detonate on barricade contact, chip soft barricades in radius\n    if (b._rocket) {\n      const ex = b.x; const ey = b.y; const radius = b._blastRadius || 70;\n      try { impactBurst(this, ex, ey, { color: 0xff3333, size: 'large', radius }); } catch (_) {}\n      this.damageSoftBarricadesInRadius(ex, ey, radius, (b.damage || 12));\n      // Napalm immediate ignite around barricade impact for MGL rockets\n      if (b._firefield) {\n        const nowI = this.time.now;\n        this.enemies.getChildren().forEach((other) => {\n          if (!other?.active || other.isDummy) return;\n          const dxn = other.x - ex; const dyn = other.y - ey;\n          if ((dxn * dxn + dyn * dyn) <= r2) {\n            other._igniteValue = Math.min(10, (other._igniteValue || 0) + 5);\n            if ((other._igniteValue || 0) >= 10) {\n              other._ignitedUntil = nowI + 2000; other._igniteValue = 0;\n              if (!other._igniteIndicator) { other._igniteIndicator = this.add.graphics(); try { other._igniteIndicator.setDepth(9000); } catch (_) {} other._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2); }\n              try { other._igniteIndicator.setPosition(other.x, other.y - 14); } catch (_) {}\n            }\n          }\n        });\n      }\n      try { b.destroy(); } catch (_) {}\n      return;\n    }\n    const dmg = (typeof b.damage === 'number' && b.damage > 0) ? b.damage : 8;\n    if (isSoft) {\n      const hp0 = (typeof s.getData('hp') === 'number') ? s.getData('hp') : 20;\n      const hp1 = hp0 - dmg;\n      if (hp1 <= 0) { try { s.destroy(); } catch (_) {} }\n      else s.setData('hp', hp1);\n    }\n    try { b.destroy(); } catch (_) {}\n  }\n\n  // Utility: damage all destructible barricades within radius\n  damageSoftBarricadesInRadius(x, y, radius, dmg) {\n    try {\n      const r2 = radius * radius;\n      const arr = this.barricadesSoft?.getChildren?.() || [];\n      for (let i = 0; i < arr.length; i += 1) {\n        const s = arr[i]; if (!s?.active) continue;\n        const dx = s.x - x; const dy = s.y - y;\n        if ((dx * dx + dy * dy) <= r2) {\n      const hp0 = (typeof s.getData('hp') === 'number') ? s.getData('hp') : 20;\n          const hp1 = hp0 - dmg;\n          if (hp1 <= 0) { try { s.destroy(); } catch (_) {} } else { s.setData('hp', hp1); }\n        }\n      }\n    } catch (_) {}\n  }\n\n  // Enemy body tries to push through a destructible barricade: damage over time\n  onEnemyHitBarricade(e, s) {\n    if (!s?.active) return;\n    if (!s.getData('destructible')) return;\n    const now = this.time.now;\n    const last = s.getData('_lastMeleeHurtAt') || 0;\n    if (now - last < 250) return; // throttle\n    s.setData('_lastMeleeHurtAt', now);\n    const dmg = Math.max(4, Math.floor((e?.damage || 8) * 0.6));\n    const hp0 = (typeof s.getData('hp') === 'number') ? s.getData('hp') : 20;\n    const hp1 = hp0 - dmg;\n    if (hp1 <= 0) { try { s.destroy(); } catch (_) {} }\n    else s.setData('hp', hp1);\n  }\n\n  // Enemy grenade hits a barricade: detonate and apply AoE\n  onEnemyGrenadeHitBarricade(b, s) {\n    if (!b || !b.active) return;\n    const ex = b.x; const ey = b.y;\n    const radius = b._grenadeRadius || 60;\n    try { impactBurst(this, ex, ey, { color: 0xff3333, size: 'large', radius }); } catch (_) {}\n    // Damage player if within radius\n    try {\n      const r2 = radius * radius; const pdx = this.player.x - ex; const pdy = this.player.y - ey;\n      if ((pdx * pdx + pdy * pdy) <= r2) {\n        const now = this.time.now;\n        if (now >= (this.player.iframesUntil || 0)) {\n          let dmg = (typeof b.damage === 'number' && b.damage > 0) ? b.damage : 14; try { const eff = getPlayerEffects(this.gs) || {}; const mul = eff.enemyExplosionDmgMul || 1; dmg = Math.ceil(dmg * mul); } catch (_) {} this.applyPlayerDamage(dmg);\n          this.player.iframesUntil = now + 600;\n          if (this.gs.hp <= 0) {\n            const eff = getPlayerEffects(this.gs);\n            this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n            this.gs.nextScene = SceneKeys.Hub;\n            SaveManager.saveToLocal(this.gs);\n            this.scene.start(SceneKeys.Hub);\n          }\n        }\n      }\n    } catch (_) {}\n    // Damage soft barricades\n    try { this.damageSoftBarricadesInRadius(ex, ey, radius, (b.damage || 14)); } catch (_) {}\n    try { b.destroy(); } catch (_) {}\n  }\n\n  // Returns true if a straight line between two points hits any barricade\n  isLineBlocked(x1, y1, x2, y2) {\n    try {\n      const line = new Phaser.Geom.Line(x1, y1, x2, y2);\n      const checkGroup = (grp) => {\n        if (!grp) return false;\n        const arr = grp.getChildren?.() || [];\n        for (let i = 0; i < arr.length; i += 1) {\n          const s = arr[i]; if (!s?.active) continue;\n          const rect = s.getBounds();\n          if (Phaser.Geom.Intersects.LineToRectangle(line, rect)) return true;\n        }\n        return false;\n      };\n      if (checkGroup(this.barricadesHard)) return true;\n      if (checkGroup(this.barricadesSoft)) return true;\n      return false;\n    } catch (_) {\n      return false;\n    }\n  }\n\n  shoot() {\n    const gs = this.gs;\n    const weapon = getEffectiveWeapon(gs, gs.activeWeapon);\n    // Trigger per-weapon recoil kick (no recoil for laser handled elsewhere)\n    try {\n      const wid = gs.activeWeapon;\n      const least = new Set(['smg', 'rifle']);\n      const medium = new Set(['pistol', 'mgl', 'battle_rifle', 'guided_missiles', 'smart_hmg']);\n      const high = new Set(['railgun', 'shotgun', 'rocket']);\n      let kick = 0;\n      if (least.has(wid)) kick = 2.0;      // least tier\n      else if (medium.has(wid)) kick = 3.5; // medium tier\n      else if (high.has(wid)) kick = 5.5;   // highest tier\n      this._weaponRecoil = Math.max(this._weaponRecoil || 0, kick);\n    } catch (_) {}\n    const baseAngle = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.inputMgr.pointer.worldX, this.inputMgr.pointer.worldY);\n    this.playerFacing = baseAngle;\n    const muzzle = getWeaponMuzzleWorld(this, 3);\n    const startX = muzzle.x;\n    const startY = muzzle.y;\n    try {\n      const wid = gs.activeWeapon;\n      const allowed = new Set(['pistol','mgl','rifle','battle_rifle','shotgun','smg','guided_missiles','smart_hmg','rocket']);\n      if (allowed.has(wid)) {\n        const heavy = new Set(['smart_hmg','guided_missiles','rocket','shotgun','mgl']);\n        if (heavy.has(wid)) muzzleFlashSplit(this, startX, startY, { angle: baseAngle, color: 0xffee66, count: 3, spreadDeg: 24, length: 16, thickness: 4 });\n        else if (wid === 'battle_rifle') muzzleFlash(this, startX, startY, { angle: baseAngle, color: 0xffee66, length: 14, thickness: 4 });\n        else muzzleFlash(this, startX, startY, { angle: baseAngle, color: 0xffee66, length: 10, thickness: 3 });\n        // Add yellow pixel spray from muzzle (wider angle overall; special tuning for heavy and battle rifle)\n        const base = baseAngle;\n        if (heavy.has(wid)) {\n          const burst = { spreadDeg: 36, speedMin: 130, speedMax: 260, lifeMs: 190, color: 0xffee66, size: 2, alpha: 0.75 };\n          pixelSparks(this, startX, startY, { angleRad: base, count: 14, ...burst });\n        } else if (wid === 'battle_rifle') {\n          const burst = { spreadDeg: 30, speedMin: 125, speedMax: 230, lifeMs: 185, color: 0xffee66, size: 2, alpha: 0.85 };\n          pixelSparks(this, startX, startY, { angleRad: base, count: 11, ...burst });\n        } else {\n          const burst = { spreadDeg: 28, speedMin: 100, speedMax: 190, lifeMs: 165, color: 0xffee66, size: 1, alpha: 0.7 };\n          pixelSparks(this, startX, startY, { angleRad: base, count: 9, ...burst });\n        }\n      }\n    } catch (_) {}\n    const pellets = weapon.pelletCount || 1;\n    // Dynamic spread: increases while holding fire, recovers when released\n    const heat = this._spreadHeat || 0;\n    const maxExtra = (typeof weapon.maxSpreadDeg === 'number') ? weapon.maxSpreadDeg : 20;\n    const extraDeg = weapon.singleFire ? 0 : (maxExtra * heat);\n    const totalSpreadRad = Phaser.Math.DegToRad((weapon.spreadDeg || 0) + extraDeg);\n    // Smart HMG bullets: limited homing toward enemies (non-explosive)\n    if (weapon.projectile === 'smart') {\n      const angle0 = baseAngle;\n      const b = this.bullets.get(startX, startY, 'bullet');\n      if (b) {\n        b.setActive(true).setVisible(true);\n        b.setCircle(2).setOffset(-2, -2);\n        b.setTint(weapon.color || 0xffaa33);\n        b.damage = weapon.damage;\n        b._core = null; // non-explosive\n        b._stunOnHit = weapon._stunOnHit || 0;\n\n        // Homing params (more limited than Smart Missiles core)\n        b._angle = angle0;\n        b._speed = Math.max(40, weapon.bulletSpeed | 0);\n        b._maxTurn = Phaser.Math.DegToRad(2) * 0.1; // ~0.2閹?frame (more limited)\n        b._fov = Phaser.Math.DegToRad(60); // narrower lock cone\n        b._noTurnUntil = this.time.now + 120; // brief straight launch\n\n        b.setVelocity(Math.cos(b._angle) * b._speed, Math.sin(b._angle) * b._speed);\n\n        // Small orange tracer similar to micro rockets but shorter\n        const g = this.add.graphics(); b._g = g; try { g.setDepth(8000); g.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n        b.update = () => {\n          const view = this.cameras?.main?.worldView; if (view && !view.contains(b.x, b.y)) { try { b.destroy(); } catch (_) {} return; }\n          try {\n            let desired = b._angle; const nowG = this.time.now;\n            if (nowG >= (b._noTurnUntil || 0)) {\n              const enemies = this.enemies?.getChildren?.() || [];\n              const half = (b._fov || Math.PI / 2) / 2; const norm = (a) => Phaser.Math.Angle.Wrap(a); const ang = norm(b._angle);\n              const valid = (t) => { if (!t?.active) return false; const a2 = Phaser.Math.Angle.Between(b.x, b.y, t.x, t.y); return Math.abs(norm(a2 - ang)) <= half; };\n              if (!valid(b._target)) {\n                b._target = null; let best=null, bestD2=Infinity;\n                for (let i = 0; i < enemies.length; i += 1) { const e = enemies[i]; if (!e?.active) continue; const a2 = Phaser.Math.Angle.Between(b.x, b.y, e.x, e.y); const dAng = Math.abs(norm(a2 - ang)); if (dAng > half) continue; const dx=e.x-b.x, dy=e.y-b.y; const d2=dx*dx+dy*dy; if (d2 < bestD2) { best=e; bestD2=d2; } }\n                b._target = best;\n              }\n              if (b._target && b._target.active) { desired = Phaser.Math.Angle.Between(b.x, b.y, b._target.x, b._target.y); }\n            }\n            b._angle = Phaser.Math.Angle.RotateTo(b._angle, desired, b._maxTurn);\n            const vx = Math.cos(b._angle) * b._speed; const vy = Math.sin(b._angle) * b._speed; b.setVelocity(vx, vy);\n          } catch (_) {}\n          try {\n            g.clear();\n            const headX = b.x + Math.cos(b._angle) * 1.5; const headY = b.y + Math.sin(b._angle) * 1.5;\n            const tailX = b.x - Math.cos(b._angle) * 6; const tailY = b.y - Math.sin(b._angle) * 6;\n            g.lineStyle(2, 0xff8800, 0.95).beginPath().moveTo(tailX + Math.cos(b._angle) * 3, tailY + Math.sin(b._angle) * 3).lineTo(headX, headY).strokePath();\n            g.lineStyle(1, 0xffddaa, 0.9).beginPath().moveTo(tailX, tailY).lineTo(b.x, b.y).strokePath();\n          } catch (_) {}\n        };\n        b.on('destroy', () => { try { b._g?.destroy(); } catch (_) {} });\n      }\n      return;\n    }\n\n    // Guided micro-missiles: home toward the cursor with limited turn rate\n    if (weapon.projectile === 'guided') {\n      const angle0 = baseAngle;\n      const b = this.bullets.get(startX, startY, 'bullet');\n      if (b) {\n        b.setActive(true).setVisible(true);\n        b.setCircle(2).setOffset(-2, -2);\n        b.setTint(weapon.color || 0xffaa33);\n        // Stats and explosive behavior\n        b.damage = weapon.damage;\n        b._aoeDamage = (typeof weapon.aoeDamage === 'number') ? weapon.aoeDamage : weapon.damage;\n        b._core = 'blast';\n        b._blastRadius = weapon.blastRadius || 40;\n        b._rocket = true; // treat as explosive projectile for AoE rules\n        b._stunOnHit = weapon._stunOnHit || 0;\n\n        // Homing parameters\n        b._angle = angle0;\n        b._speed = Math.max(40, weapon.bulletSpeed | 0); // low velocity\n        // Max turn per frame (reduced turn rate ~2 deg/frame)\n        b._maxTurn = Phaser.Math.DegToRad(2);\n        // Smart Missiles core: enable enemy-seeking and reduce turn further\n        b._smart = !!weapon._smartMissiles;\n        if (b._smart) {\n          const mult = (typeof weapon._smartTurnMult === 'number') ? Math.max(0.1, weapon._smartTurnMult) : 0.5;\n          b._maxTurn = b._maxTurn * mult; // e.g., 1閹?frame\n          b._fov = Phaser.Math.DegToRad(90); // 90閹?cone total\n        }\n        // Initial straight flight window (no steering)\n        b._noTurnUntil = this.time.now + 200; // ms\n\n        // Initial velocity\n        b.setVelocity(Math.cos(b._angle) * b._speed, Math.sin(b._angle) * b._speed);\n\n        // Tracer/visual tail\n        const g = this.add.graphics();\n        b._g = g; try { g.setDepth(8000); g.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n\n        b.update = () => {\n          // Offscreen cleanup\n          const view = this.cameras?.main?.worldView;\n          if (view && !view.contains(b.x, b.y)) { try { b.destroy(); } catch (_) {} return; }\n\n          // Guidance\n          try {\n            let desired = b._angle;\n            const nowG = this.time.now;\n            if (nowG >= (b._noTurnUntil || 0)) {\n              if (b._smart) {\n                // Maintain/refresh target within FOV; otherwise go straight\n                const enemies = this.enemies?.getChildren?.() || [];\n                const half = (b._fov || Math.PI / 2) / 2; // 45閹?half-angle\n                const norm = (a) => Phaser.Math.Angle.Wrap(a);\n                const ang = norm(b._angle);\n                // Validate existing target\n                const validExisting = (t) => {\n                  if (!t?.active) return false;\n                  const a2 = Phaser.Math.Angle.Between(b.x, b.y, t.x, t.y);\n                  const d = Math.abs(norm(a2 - ang));\n                  return d <= half;\n                };\n                if (!validExisting(b._target)) {\n                  b._target = null;\n                  // Find nearest within FOV cone\n                  let best = null; let bestD2 = Infinity;\n                  for (let i = 0; i < enemies.length; i += 1) {\n                    const e = enemies[i]; if (!e?.active) continue;\n                    const a2 = Phaser.Math.Angle.Between(b.x, b.y, e.x, e.y);\n                    const dAng = Math.abs(norm(a2 - ang));\n                    if (dAng > half) continue;\n                    const dx = e.x - b.x; const dy = e.y - b.y; const d2 = dx * dx + dy * dy;\n                    if (d2 < bestD2) { best = e; bestD2 = d2; }\n                  }\n                  b._target = best;\n                }\n                if (b._target && b._target.active) {\n                  desired = Phaser.Math.Angle.Between(b.x, b.y, b._target.x, b._target.y);\n                } else {\n                  // No target in cone: keep heading\n                  desired = b._angle;\n                }\n              } else {\n                // Follow cursor (default guided behavior)\n                const ptr = this.inputMgr?.pointer;\n                const tx = ptr?.worldX ?? (this.player.x + Math.cos(this.playerFacing) * 2000);\n                const ty = ptr?.worldY ?? (this.player.y + Math.sin(this.playerFacing) * 2000);\n                desired = Phaser.Math.Angle.Between(b.x, b.y, tx, ty);\n              }\n            } // else: within straight-flight window; keep current desired (= b._angle)\n            b._angle = Phaser.Math.Angle.RotateTo(b._angle, desired, b._maxTurn);\n            const vx = Math.cos(b._angle) * b._speed;\n            const vy = Math.sin(b._angle) * b._speed;\n            b.setVelocity(vx, vy);\n          } catch (_) {}\n\n          // Draw small elongated orange body + tracer tail\n          try {\n            g.clear();\n            const headX = b.x + Math.cos(b._angle) * 2;\n            const headY = b.y + Math.sin(b._angle) * 2;\n            const tailX = b.x - Math.cos(b._angle) * 8;\n            const tailY = b.y - Math.sin(b._angle) * 8;\n            // Body (thicker, short)\n            g.lineStyle(3, 0xff8800, 0.95);\n            g.beginPath(); g.moveTo(tailX + Math.cos(b._angle) * 4, tailY + Math.sin(b._angle) * 4); g.lineTo(headX, headY); g.strokePath();\n            // Tracer (thin, longer)\n            g.lineStyle(1, 0xffddaa, 0.9);\n            g.beginPath(); g.moveTo(tailX, tailY); g.lineTo(b.x, b.y); g.strokePath();\n          } catch (_) {}\n        };\n        b.on('destroy', () => { try { b._g?.destroy(); } catch (_) {} });\n      }\n      return;\n    }\n\n    // Rocket projectile: explode on hit or when reaching click position\n    if (weapon.projectile === 'rocket') {\n      const targetX = this.inputMgr.pointer.worldX;\n      const targetY = this.inputMgr.pointer.worldY;\n      const angle = baseAngle;\n      const vx = Math.cos(angle) * weapon.bulletSpeed;\n      const vy = Math.sin(angle) * weapon.bulletSpeed;\n      const b = this.bullets.get(startX, startY, 'bullet');\n      if (b) {\n        b.setActive(true).setVisible(true);\n        // Larger rocket visual + hitbox\n        b.setCircle(6).setOffset(-6, -6);\n        try { b.setScale(1.8); } catch (_) {}\n        b.setVelocity(vx, vy);\n        b.setTint(weapon.color || 0xff5533);\n        // Use weapon.damage for direct-hit; carry AoE damage separately\n        b.damage = weapon.damage;\n        b._aoeDamage = (typeof weapon.aoeDamage === 'number') ? weapon.aoeDamage : weapon.damage;\n        b._core = 'blast';\n        b._blastRadius = weapon.blastRadius || 70;\n        b._rocket = true;\n        // Carry stun-on-hit value for direct impacts (from Stun Ammunitions)\n        b._stunOnHit = weapon._stunOnHit || 0;\n        // Smart Explosives core flags\n        b._smartExplosives = !!weapon._smartExplosives;\n        b._firefield = !!weapon._firefield;\n        if (b._smartExplosives) {\n          const scale = (typeof weapon._detectScale === 'number') ? weapon._detectScale : 0.65;\n          b._detectR = Math.max(8, Math.floor((b._blastRadius || 70) * scale));\n        }\n        b._startX = startX; b._startY = startY;\n        b._targetX = targetX; b._targetY = targetY;\n        const sx = targetX - startX; const sy = targetY - startY;\n        b._targetLen2 = sx * sx + sy * sy;\n        b.update = () => {\n          // Lifetime via camera view when walls are disabled\n          const view = this.cameras?.main?.worldView;\n          if (view && !view.contains(b.x, b.y)) {\n            // Do not cull mines off-screen; allow them to persist\n            if (!b._mine) { try { b.destroy(); } catch (_) {} return; }\n          }\n          // Napalm (MGL incendiary) rocket: add orange tracer particles behind projectile\n          try {\n            if (b._firefield) {\n              const vx0 = b.body?.velocity?.x || 0; const vy0 = b.body?.velocity?.y || 0;\n              const spd2 = (vx0*vx0 + vy0*vy0) || 0;\n              if (spd2 > 1) {\n                const back = Math.atan2(vy0, vx0) + Math.PI;\n                const ex = b.x + Math.cos(back) * 6; const ey = b.y + Math.sin(back) * 6;\n                pixelSparks(this, ex, ey, { angleRad: back, count: 2, spreadDeg: 8, speedMin: 90, speedMax: 180, lifeMs: 110, color: 0xffaa33, size: 2, alpha: 0.95 });\n              }\n            }\n          } catch (_) {}\n          // Smart Explosives: proximity detection and mine behavior\n          if (b._smartExplosives) {\n            const detR = b._detectR || Math.max(8, Math.floor((b._blastRadius || 70) * 0.65));\n            const detR2 = detR * detR;\n            const now = this.time.now;\n            // If deployed as a mine, sit until enemy enters detection or expiry\n            if (b._mine) {\n              if (now >= (b._mineExpireAt || 0)) {\n                // Expire by detonating rather than disappearing silently\n                const ex = b.x; const ey = b.y;\n                try { impactBurst(this, ex, ey, { color: 0xffaa33, size: 'large', radius: b._blastRadius || 40 }); } catch (_) {}\n                const radius = b._blastRadius || 70; const r2 = radius * radius;\n                this.enemies.getChildren().forEach((other) => {\n                  if (!other.active) return; const ddx = other.x - ex; const ddy = other.y - ey;\n                  if ((ddx * ddx + ddy * ddy) <= r2) {\n                    const aoe = (b._aoeDamage || b.damage || 10);\n                    if (other.isDummy) { this._dummyDamage = (this._dummyDamage || 0) + aoe; }\n                    else { if (typeof other.hp !== 'number') other.hp = other.maxHp || 20; other.hp -= aoe; if (other.hp <= 0) { this.killEnemy(other); } }\n                  }\n                });\n                this.damageSoftBarricadesInRadius(ex, ey, radius, (b._aoeDamage || b.damage || 10));\n                if (b._firefield) {\n                  this.spawnFireField(ex, ey, radius);\n                  const r2n = radius * radius; const nowI = this.time.now;\n                  this.enemies.getChildren().forEach((other) => {\n                    if (!other?.active || other.isDummy) return;\n                    const dxn = other.x - ex; const dyn = other.y - ey;\n                    if ((dxn * dxn + dyn * dyn) <= r2n) {\n                      other._igniteValue = Math.min(10, (other._igniteValue || 0) + 5);\n                      if ((other._igniteValue || 0) >= 10) {\n                        other._ignitedUntil = nowI + 2000; other._igniteValue = 0;\n                        if (!other._igniteIndicator) { other._igniteIndicator = this.add.graphics(); try { other._igniteIndicator.setDepth(9000); } catch (_) {} other._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2); }\n                        try { other._igniteIndicator.setPosition(other.x, other.y - 14); } catch (_) {}\n                      }\n                    }\n                  });\n                }\n                try { b.destroy(); } catch (_) {}\n                return;\n              }\n              const arr = this.enemies?.getChildren?.() || [];\n              for (let i = 0; i < arr.length; i += 1) {\n                const e = arr[i]; if (!e?.active) continue;\n                const dx = e.x - b.x; const dy = e.y - b.y;\n                if ((dx * dx + dy * dy) <= detR2) {\n                  const ex = b.x; const ey = b.y;\n                  try { impactBurst(this, ex, ey, { color: 0xffaa33, size: 'large', radius: b._blastRadius || 40 }); } catch (_) {}\n                  const radius = b._blastRadius || 70; const r2 = radius * radius;\n                  this.enemies.getChildren().forEach((other) => {\n                    if (!other.active) return; const ddx = other.x - ex; const ddy = other.y - ey;\n                    if ((ddx * ddx + ddy * ddy) <= r2) {\n                      const aoe = (b._aoeDamage || b.damage || 10);\n                      if (other.isDummy) { this._dummyDamage = (this._dummyDamage || 0) + aoe; }\n                      else { if (typeof other.hp !== 'number') other.hp = other.maxHp || 20; other.hp -= aoe; if (other.hp <= 0) { this.killEnemy(other); } }\n                    }\n                  });\n                  this.damageSoftBarricadesInRadius(ex, ey, radius, (b._aoeDamage || b.damage || 10));\n                  if (b._firefield) {\n                    this.spawnFireField(ex, ey, radius);\n                    const r2n = radius * radius; const nowI = this.time.now;\n                    this.enemies.getChildren().forEach((other) => {\n                      if (!other?.active || other.isDummy) return;\n                      const dxn = other.x - ex; const dyn = other.y - ey;\n                      if ((dxn * dxn + dyn * dyn) <= r2n) {\n                        other._igniteValue = Math.min(10, (other._igniteValue || 0) + 5);\n                        if ((other._igniteValue || 0) >= 10) {\n                          other._ignitedUntil = nowI + 2000; other._igniteValue = 0;\n                          if (!other._igniteIndicator) { other._igniteIndicator = this.add.graphics(); try { other._igniteIndicator.setDepth(9000); } catch (_) {} other._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2); }\n                          try { other._igniteIndicator.setPosition(other.x, other.y - 14); } catch (_) {}\n                        }\n                      }\n                    });\n                  }\n                  try { b.destroy(); } catch (_) {}\n                  return;\n                }\n              }\n              // Stay as mine this frame\n              return;\n            }\n            // While flying: proximity-detonate if any enemy within detect radius\n            {\n              const arr = this.enemies?.getChildren?.() || [];\n              for (let i = 0; i < arr.length; i += 1) {\n                const e = arr[i]; if (!e?.active) continue;\n                const dx = e.x - b.x; const dy = e.y - b.y;\n                if ((dx * dx + dy * dy) <= detR2) {\n                  const ex = b.x; const ey = b.y;\n                  try { impactBurst(this, ex, ey, { color: 0xffaa33, size: 'large', radius: b._blastRadius || 40 }); } catch (_) {}\n                  const radius = b._blastRadius || 70; const r2 = radius * radius;\n                  this.enemies.getChildren().forEach((other) => {\n                    if (!other.active) return; const ddx = other.x - ex; const ddy = other.y - ey;\n                    if ((ddx * ddx + ddy * ddy) <= r2) {\n                      const aoe = (b._aoeDamage || b.damage || 10);\n                      if (other.isDummy) { this._dummyDamage = (this._dummyDamage || 0) + aoe; }\n                      else { if (typeof other.hp !== 'number') other.hp = other.maxHp || 20; other.hp -= aoe; if (other.hp <= 0) { this.killEnemy(other); } }\n                    }\n                  });\n                  this.damageSoftBarricadesInRadius(ex, ey, radius, (b._aoeDamage || b.damage || 10));\n                  if (b._firefield) {\n                    this.spawnFireField(ex, ey, radius);\n                    const r2n = radius * radius; const nowI = this.time.now;\n                    this.enemies.getChildren().forEach((other) => {\n                      if (!other?.active || other.isDummy) return;\n                      const dxn = other.x - ex; const dyn = other.y - ey;\n                      if ((dxn * dxn + dyn * dyn) <= r2n) {\n                        other._igniteValue = Math.min(10, (other._igniteValue || 0) + 5);\n                        if ((other._igniteValue || 0) >= 10) {\n                          other._ignitedUntil = nowI + 2000; other._igniteValue = 0;\n                          if (!other._igniteIndicator) { other._igniteIndicator = this.add.graphics(); try { other._igniteIndicator.setDepth(9000); } catch (_) {} other._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2); }\n                          try { other._igniteIndicator.setPosition(other.x, other.y - 14); } catch (_) {}\n                        }\n                      }\n                    });\n                  }\n                  try { b.destroy(); } catch (_) {}\n                  return;\n                }\n              }\n            }\n          }\n          // Check if reached or passed target point\n          const dxs = (b.x - b._startX); const dys = (b.y - b._startY);\n          const prog = dxs * (sx) + dys * (sy);\n          const dx = b.x - b._targetX; const dy = b.y - b._targetY;\n          const nearTarget = (dx * dx + dy * dy) <= 64; // within 8px\n          const passed = prog >= b._targetLen2 - 1;\n          if (nearTarget || passed) {\n            if (b._smartExplosives) {\n              // Become a mine if no enemy in detection radius\n              b._mine = true;\n              b._mineExpireAt = this.time.now + 8000; // safety timeout\n              try { b.setVelocity(0, 0); } catch (_) {}\n              try { b.body?.setVelocity?.(0, 0); } catch (_) {}\n              try { b.setTint(0x55ff77); } catch (_) {}\n              return;\n            }\n            // Explode at target/current pos\n            const ex = b.x; const ey = b.y;\n            try { impactBurst(this, ex, ey, { color: 0xffaa33, size: 'large', radius: b._blastRadius || 40 }); } catch (_) {}\n            const radius = b._blastRadius || 70; const r2 = radius * radius;\n            this.enemies.getChildren().forEach((other) => {\n              if (!other.active) return;\n              const ddx = other.x - ex; const ddy = other.y - ey;\n              if ((ddx * ddx + ddy * ddy) <= r2) {\n                const aoe = (b._aoeDamage || b.damage || 10);\n                if (other.isDummy) {\n                  this._dummyDamage = (this._dummyDamage || 0) + aoe;\n                } else {\n                  if (typeof other.hp !== 'number') other.hp = other.maxHp || 20;\n                  other.hp -= aoe;\n                  if (other.hp <= 0) { this.killEnemy(other); }\n                }\n              }\n            });\n            // Also damage nearby destructible barricades\n            this.damageSoftBarricadesInRadius(ex, ey, radius, (b._aoeDamage || b.damage || 10));\n            if (b._firefield) {\n              this.spawnFireField(ex, ey, radius);\n              const r2n = radius * radius; const nowI = this.time.now;\n              this.enemies.getChildren().forEach((other) => {\n                if (!other?.active || other.isDummy) return;\n                const dxn = other.x - ex; const dyn = other.y - ey;\n                if ((dxn * dxn + dyn * dyn) <= r2n) {\n                  other._igniteValue = Math.min(10, (other._igniteValue || 0) + 5);\n                  if ((other._igniteValue || 0) >= 10) {\n                    other._ignitedUntil = nowI + 2000; other._igniteValue = 0;\n                    if (!other._igniteIndicator) { other._igniteIndicator = this.add.graphics(); try { other._igniteIndicator.setDepth(9000); } catch (_) {} other._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2); }\n                    try { other._igniteIndicator.setPosition(other.x, other.y - 14); } catch (_) {}\n                  }\n                }\n              });\n            }\n            try { b.destroy(); } catch (_) {}\n          }\n        };\n        b.on('destroy', () => b._g?.destroy());\n      }\n      return;\n    }\n    for (let i = 0; i < pellets; i += 1) {\n      let angle = baseAngle;\n      if (pellets === 1) {\n        // Single bullet: apply random deviation within the total spread cone\n        const off = Phaser.Math.FloatBetween(-0.5, 0.5) * totalSpreadRad;\n        angle += off;\n      } else {\n        // Multi-pellet: distribute across the total spread with slight jitter\n        const t = (i / (pellets - 1)) - 0.5;\n        angle += t * totalSpreadRad;\n        if (totalSpreadRad > 0) angle += Phaser.Math.FloatBetween(-0.1, 0.1) * totalSpreadRad;\n      }\n      // Increase bullet speed for all non-rocket projectiles\n      const effSpeed = (weapon.projectile === 'rocket') ? weapon.bulletSpeed : Math.floor((weapon.bulletSpeed || 0) * 1.25);\n      const vx = Math.cos(angle) * effSpeed;\n      const vy = Math.sin(angle) * effSpeed;\n      const b = this.bullets.get(startX, startY, 'bullet');\n      if (!b) continue;\n      b.setActive(true).setVisible(true);\n      b.setCircle(2).setOffset(-2, -2);\n      b.setVelocity(vx, vy);\n      // Bullet tint: default white; Explosive Core uses orange bullets\n      if (weapon._core === 'blast') b.setTint(0xff8800); else b.setTint(0xffffff);\n      b.damage = weapon.damage;\n      b._core = weapon._core || null;\n      b._igniteOnHit = weapon._igniteOnHit || 0;\n      b._toxinOnHit = weapon._toxinOnHit || 0;\n      b._stunOnHit = weapon._stunOnHit || 0;\n      if (b._core === 'pierce') { b._pierceLeft = 1; }\n      // Tracer setup: particle thruster for stun/toxin/incendiary; blue line for pierce core\n      try {\n        // Particle tracer colors\n        const tracerColor = (() => {\n          if (b._toxinOnHit > 0) return 0x33ff66; // green\n          if (b._igniteOnHit > 0) return 0xffaa33; // orange\n          if (b._stunOnHit > 0) return 0xffee66; // yellow\n          return null;\n        })();\n        if (b._core === 'pierce') {\n          const g = this.add.graphics(); b._g = g; try { g.setDepth(8000); g.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n          b.update = () => {\n            const view = this.cameras?.main?.worldView;\n            if (view && !view.contains(b.x, b.y)) { b.destroy(); return; }\n            try {\n              g.clear();\n              const vx0 = b.body?.velocity?.x || vx; const vy0 = b.body?.velocity?.y || vy;\n              const ang = Math.atan2(vy0, vx0);\n              const tail = 10;\n              const tx = b.x - Math.cos(ang) * tail; const ty = b.y - Math.sin(ang) * tail;\n              g.lineStyle(3, 0x2266ff, 0.5).beginPath().moveTo(tx, ty).lineTo(b.x, b.y).strokePath();\n              g.lineStyle(1, 0xaaddff, 0.9).beginPath().moveTo(tx + Math.cos(ang) * 2, ty + Math.sin(ang) * 2).lineTo(b.x, b.y).strokePath();\n            } catch (_) {}\n          };\n          b.on('destroy', () => { try { b._g?.destroy(); } catch (_) {} });\n        } else if (tracerColor && weapon._core !== 'blast') {\n          // Emit stronger thruster-like particles behind the bullet each frame\n          b.update = () => {\n            const view = this.cameras?.main?.worldView;\n            if (view && !view.contains(b.x, b.y)) { b.destroy(); return; }\n            try {\n              const vx0 = b.body?.velocity?.x || vx; const vy0 = b.body?.velocity?.y || vy;\n              const back = Math.atan2(vy0, vx0) + Math.PI;\n              const ex = b.x + Math.cos(back) * 5; const ey = b.y + Math.sin(back) * 5;\n              // Scale tracer strength by effect type\n              const isIgnite = (b._igniteOnHit || 0) > 0;\n              const isToxin  = (b._toxinOnHit  || 0) > 0;\n              const isStun   = (b._stunOnHit   || 0) > 0;\n              let count = 2, size = 2, lifeMs = 100, speedMin = 90, speedMax = 180, alpha = 0.9;\n              if (isIgnite) { count = 3; size = 2; lifeMs = 120; speedMin = 100; speedMax = 200; alpha = 0.95; }\n              else if (isToxin) { count = 2; size = 2; lifeMs = 110; speedMin = 90; speedMax = 190; alpha = 0.92; }\n              else if (isStun) { count = 2; size = 2; lifeMs = 100; speedMin = 90; speedMax = 180; alpha = 0.9; }\n              pixelSparks(this, ex, ey, { angleRad: back, count, spreadDeg: 8, speedMin, speedMax, lifeMs, color: tracerColor, size, alpha });\n            } catch (_) {}\n          };\n          b.on('destroy', () => b._g?.destroy());\n        } else {\n          b.update = () => {\n            const view = this.cameras?.main?.worldView;\n            if (view && !view.contains(b.x, b.y)) { b.destroy(); return; }\n          };\n          b.on('destroy', () => b._g?.destroy());\n        }\n      } catch (_) {\n        b.update = () => {\n          const view = this.cameras?.main?.worldView;\n          if (view && !view.contains(b.x, b.y)) { b.destroy(); return; }\n        };\n      }\n      b.on('destroy', () => b._g?.destroy());\n    }\n    // Burst Fire core: schedule additional shots within a short window\n    if (weapon._burstN && weapon._burstN > 1) {\n      const wid = this.gs.activeWeapon;\n      const ang = baseAngle;\n      const perGap = Math.max(30, weapon._burstGapMs || 70);\n      for (let k = 1; k < weapon._burstN; k += 1) {\n        this.time.delayedCall(perGap * k, () => {\n          if (this.gs.activeWeapon !== wid) return;\n          const cap = this.getActiveMagCapacity();\n          this.ensureAmmoFor(wid, cap);\n          const ammo = this.ammoByWeapon[wid] ?? 0;\n          if (ammo <= 0 || this.reload.active) return;\n          const effSpeed = Math.floor((weapon.bulletSpeed || 0) * 1.25);\n          const vx = Math.cos(ang) * effSpeed;\n          const vy = Math.sin(ang) * effSpeed;\n          const m = getWeaponMuzzleWorld(this, 3);\n          try {\n            const wid = this.gs.activeWeapon;\n            const allowed = new Set(['pistol','mgl','rifle','battle_rifle','shotgun','smg','guided_missiles','smart_hmg','rocket']);\n            if (allowed.has(wid)) {\n              const heavy = new Set(['smart_hmg','guided_missiles','rocket','shotgun','mgl']);\n              if (heavy.has(wid)) muzzleFlashSplit(this, m.x, m.y, { angle: ang, color: 0xffee66, count: 3, spreadDeg: 24, length: 16, thickness: 4 });\n              else if (wid === 'battle_rifle') muzzleFlash(this, m.x, m.y, { angle: ang, color: 0xffee66, length: 14, thickness: 4 });\n              else muzzleFlash(this, m.x, m.y, { angle: ang, color: 0xffee66, length: 10, thickness: 3 });\n              // Burst yellow muzzle pixels for bursts (wider overall, special battle rifle)\n              const base = ang;\n              if (heavy.has(wid)) {\n                const burst = { spreadDeg: 36, speedMin: 130, speedMax: 260, lifeMs: 180, color: 0xffee66, size: 2, alpha: 0.75 };\n                pixelSparks(this, m.x, m.y, { angleRad: base, count: 12, ...burst });\n              } else if (wid === 'battle_rifle') {\n                const burst = { spreadDeg: 30, speedMin: 125, speedMax: 230, lifeMs: 185, color: 0xffee66, size: 2, alpha: 0.85 };\n                pixelSparks(this, m.x, m.y, { angleRad: base, count: 10, ...burst });\n              } else {\n                const burst = { spreadDeg: 28, speedMin: 100, speedMax: 190, lifeMs: 165, color: 0xffee66, size: 1, alpha: 0.7 };\n                pixelSparks(this, m.x, m.y, { angleRad: base, count: 8, ...burst });\n              }\n            }\n          } catch (_) {}\n          const bN = this.bullets.get(m.x, m.y, 'bullet');\n          if (!bN) return;\n          bN.setActive(true).setVisible(true);\n          bN.setCircle(2).setOffset(-2, -2);\n          bN.setVelocity(vx, vy);\n          bN.setTint(0xffffff);\n          bN.damage = weapon.damage;\n          bN._core = weapon._core || null;\n          bN._igniteOnHit = weapon._igniteOnHit || 0;\n          bN._toxinOnHit = weapon._toxinOnHit || 0;\n          bN._stunOnHit = weapon._stunOnHit || 0;\n          if (bN._core === 'pierce') { bN._pierceLeft = 1; }\n          bN.update = () => {\n            const view = this.cameras?.main?.worldView;\n            if (view && !view.contains(bN.x, bN.y)) { try { bN.destroy(); } catch (_) {} }\n          };\n          bN.on('destroy', () => bN._g?.destroy());\n          // consume ammo and sync UI\n          this.ammoByWeapon[wid] = Math.max(0, ammo - 1);\n          this.registry.set('ammoInMag', this.ammoByWeapon[wid]);\n        });\n      }\n    }\n    // 2Tap Trigger: schedule an automatic second accurate shot shortly after\n    if (weapon._twoTap) {\n      const wid = this.gs.activeWeapon;\n      const angle2 = baseAngle;\n      this.time.delayedCall(70, () => {\n        if (this.gs.activeWeapon !== wid) return;\n        const cap = this.getActiveMagCapacity();\n        this.ensureAmmoFor(wid, cap);\n        const ammo = this.ammoByWeapon[wid] ?? 0;\n        if (ammo <= 0 || this.reload.active) return;\n        const effSpeed = Math.floor((weapon.bulletSpeed || 0) * 1.25);\n        const vx = Math.cos(angle2) * effSpeed;\n        const vy = Math.sin(angle2) * effSpeed;\n        const m2 = getWeaponMuzzleWorld(this, 3);\n        try {\n          const wid = this.gs.activeWeapon;\n          const allowed = new Set(['pistol','mgl','rifle','battle_rifle','shotgun','smg','guided_missiles','smart_hmg','rocket']);\n          if (allowed.has(wid)) {\n            const heavy = new Set(['smart_hmg','guided_missiles','rocket','shotgun','mgl']);\n            if (heavy.has(wid)) muzzleFlashSplit(this, m2.x, m2.y, { angle: angle2, color: 0xffee66, count: 3, spreadDeg: 24, length: 16, thickness: 4 });\n            else if (wid === 'battle_rifle') muzzleFlash(this, m2.x, m2.y, { angle: angle2, color: 0xffee66, length: 14, thickness: 4 });\n            else muzzleFlash(this, m2.x, m2.y, { angle: angle2, color: 0xffee66, length: 10, thickness: 3 });\n            const base = angle2;\n            if (heavy.has(wid)) {\n              const burst = { spreadDeg: 36, speedMin: 130, speedMax: 260, lifeMs: 180, color: 0xffee66, size: 2, alpha: 0.75 };\n              pixelSparks(this, m2.x, m2.y, { angleRad: base, count: 12, ...burst });\n            } else if (wid === 'battle_rifle') {\n              const burst = { spreadDeg: 30, speedMin: 125, speedMax: 230, lifeMs: 185, color: 0xffee66, size: 2, alpha: 0.85 };\n              pixelSparks(this, m2.x, m2.y, { angleRad: base, count: 10, ...burst });\n            } else {\n              const burst = { spreadDeg: 28, speedMin: 100, speedMax: 190, lifeMs: 165, color: 0xffee66, size: 1, alpha: 0.7 };\n              pixelSparks(this, m2.x, m2.y, { angleRad: base, count: 8, ...burst });\n            }\n          }\n        } catch (_) {}\n        const b2 = this.bullets.get(m2.x, m2.y, 'bullet');\n        if (!b2) return;\n        b2.setActive(true).setVisible(true);\n        b2.setCircle(2).setOffset(-2, -2);\n        b2.setVelocity(vx, vy);\n         // Tint rules match primary: Explosive Core turns bullet orange\n         if (weapon._core === 'blast') b2.setTint(0xff8800); else b2.setTint(0xffffff);\n         b2.damage = weapon.damage;\n         b2._core = weapon._core || null;\n         b2._igniteOnHit = weapon._igniteOnHit || 0;\n         b2._toxinOnHit = weapon._toxinOnHit || 0;\n         b2._stunOnHit = weapon._stunOnHit || 0;\n         if (b2._core === 'pierce') { b2._pierceLeft = 1; }\n        try {\n          const tracerColor2 = (() => {\n            if (b2._toxinOnHit > 0) return 0x33ff66; // green\n            if (b2._igniteOnHit > 0) return 0xffaa33; // orange\n            if (b2._stunOnHit > 0) return 0xffee66; // yellow\n            return null;\n          })();\n          if (b2._core === 'pierce') {\n            const g2 = this.add.graphics(); b2._g = g2; try { g2.setDepth(8000); g2.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n            b2.update = () => {\n              const view = this.cameras?.main?.worldView; if (view && !view.contains(b2.x, b2.y)) { try { b2.destroy(); } catch (_) {} return; }\n              try {\n                g2.clear();\n                const vx0 = b2.body?.velocity?.x || vx; const vy0 = b2.body?.velocity?.y || vy;\n                const ang = Math.atan2(vy0, vx0);\n                const tail = 10;\n                const tx = b2.x - Math.cos(ang) * tail; const ty = b2.y - Math.sin(ang) * tail;\n                g2.lineStyle(3, 0x2266ff, 0.5).beginPath().moveTo(tx, ty).lineTo(b2.x, b2.y).strokePath();\n                g2.lineStyle(1, 0xaaddff, 0.9).beginPath().moveTo(tx + Math.cos(ang) * 2, ty + Math.sin(ang) * 2).lineTo(b2.x, b2.y).strokePath();\n              } catch (_) {}\n            };\n            b2.on('destroy', () => { try { b2._g?.destroy(); } catch (_) {} });\n          } else if (tracerColor2 && weapon._core !== 'blast') {\n            // Stronger tracer on burst bullets too\n            b2.update = () => {\n              const view = this.cameras?.main?.worldView; if (view && !view.contains(b2.x, b2.y)) { try { b2.destroy(); } catch (_) {} return; }\n              try {\n                const vx0 = b2.body?.velocity?.x || vx; const vy0 = b2.body?.velocity?.y || vy;\n                const back = Math.atan2(vy0, vx0) + Math.PI;\n                const ex = b2.x + Math.cos(back) * 5; const ey = b2.y + Math.sin(back) * 5;\n                const isIgnite = (b2._igniteOnHit || 0) > 0;\n                const isToxin  = (b2._toxinOnHit  || 0) > 0;\n                const isStun   = (b2._stunOnHit   || 0) > 0;\n                let count = 2, size = 2, lifeMs = 100, speedMin = 90, speedMax = 180, alpha = 0.9;\n                if (isIgnite) { count = 3; size = 2; lifeMs = 120; speedMin = 100; speedMax = 200; alpha = 0.95; }\n                else if (isToxin) { count = 2; size = 2; lifeMs = 110; speedMin = 90; speedMax = 190; alpha = 0.92; }\n                else if (isStun) { count = 2; size = 2; lifeMs = 100; speedMin = 90; speedMax = 180; alpha = 0.9; }\n                pixelSparks(this, ex, ey, { angleRad: back, count, spreadDeg: 8, speedMin, speedMax, lifeMs, color: tracerColor2, size, alpha });\n              } catch (_) {}\n            };\n            b2.on('destroy', () => b2._g?.destroy());\n          } else {\n            b2.update = () => {\n              const view = this.cameras?.main?.worldView;\n              if (view && !view.contains(b2.x, b2.y)) { try { b2.destroy(); } catch (_) {} }\n            };\n            b2.on('destroy', () => b2._g?.destroy());\n          }\n        } catch (_) {\n          b2.update = () => {\n            const view = this.cameras?.main?.worldView; if (view && !view.contains(b2.x, b2.y)) { try { b2.destroy(); } catch (_) {} }\n          };\n        }\n        b2.on('destroy', () => b2._g?.destroy());\n        // consume ammo and sync UI\n        this.ammoByWeapon[wid] = Math.max(0, ammo - 1);\n        this.registry.set('ammoInMag', this.ammoByWeapon[wid]);\n      });\n    }\n  }\n\n  update() {\n    // Update dash charge display for UI\n    this.registry.set('dashCharges', this.dash.charges);\n    // Dash regen progress for UI (0..1) for the next slot\n    let prog = 0;\n    const eff = getPlayerEffects(this.gs);\n    if (this.dash.charges < this.gs.dashMaxCharges && this.dash.regen.length) {\n      const now = this.time.now;\n      const nextReady = Math.min(...this.dash.regen);\n      const remaining = Math.max(0, nextReady - now);\n      const denom = (eff.dashRegenMs || this.gs.dashRegenMs || 1000);\n      prog = 1 - Math.min(1, remaining / denom);\n    } else {\n      prog = 1;\n    }\n    this.registry.set('dashRegenProgress', prog);\n\n    // Dash handling\n    const now = this.time.now;\n    if (this.inputMgr.pressedDash && now >= this.dash.cooldownUntil && this.dash.charges > 0) {\n      const dir = this.inputMgr.moveVec;\n      const angle = (dir.x !== 0 || dir.y !== 0) ? Math.atan2(dir.y, dir.x) : this.playerFacing;\n      const dashSpeed = 520;\n      const dur = 180;\n      this.dash.active = true;\n      this.dash.until = now + dur;\n      this.dash.cooldownUntil = now + 600;\n      this.dash.vx = Math.cos(angle) * dashSpeed;\n      this.dash.vy = Math.sin(angle) * dashSpeed;\n      this.player.iframesUntil = now + dur; // i-frames while dashing\n      // consume charge and queue regen\n      this.dash.charges -= 1;\n      this.dash.regen.push(now + (eff.dashRegenMs || this.gs.dashRegenMs));\n    }\n\n    if (this.dash.active && now < this.dash.until) {\n      this.player.setVelocity(this.dash.vx, this.dash.vy);\n    } else {\n      this.dash.active = false;\n      const mv = this.inputMgr.moveVec;\n      const speed = 200 * (eff.moveSpeedMult || 1);\n      this.player.setVelocity(mv.x * speed, mv.y * speed);\n    }\n\n    // Regen charges\n    if (this.dash.regen.length) {\n      const ready = this.dash.regen.filter((t) => now >= t);\n      if (ready.length) {\n        const remaining = this.dash.regen.filter((t) => now < t);\n        this.dash.regen = remaining;\n        this.dash.charges = Math.min(this.dash.charges + ready.length, this.gs.dashMaxCharges);\n      }\n    }\n\n    // Shooting with LMB per weapon fireRate\n    const weapon = getEffectiveWeapon(this.gs, this.gs.activeWeapon);\n    const isRail = !!weapon.isRailgun;\n    const isLaser = !!weapon.isLaser;\n    // Finish reload if timer elapsed; update reload progress for UI\n    if (this.reload?.active) {\n      const now = this.time.now;\n      const remaining = Math.max(0, this.reload.until - now);\n      const dur = Math.max(1, this.reload.duration || this.getActiveReloadMs());\n      const prog = 1 - Math.min(1, remaining / dur);\n      this.registry.set('reloadActive', true);\n      this.registry.set('reloadProgress', prog);\n      if (now >= this.reload.until) {\n        const wid = this.gs.activeWeapon;\n        const cap = this.getActiveMagCapacity();\n        this.ensureAmmoFor(wid, cap);\n        this.ammoByWeapon[wid] = cap;\n        this.registry.set('ammoInMag', this.ammoByWeapon[wid]);\n        this.registry.set('magSize', cap);\n        this.reload.active = false;\n        this.reload.duration = 0;\n        this.registry.set('reloadActive', false);\n        this.registry.set('reloadProgress', 1);\n      }\n    } else {\n      this.registry.set('reloadActive', false);\n    }\n\n    // Shooting Range interactions\n    if (this.gs?.shootingRange) {\n      // Update dummy label position and text\n      if (this.dummy && this.dummyLabel) {\n        try {\n          this.dummyLabel.setPosition(this.dummy.x, this.dummy.y - 16);\n          this.dummyLabel.setText(`DMG: ${this._dummyDamage | 0}`);\n        } catch (_) {}\n      }\n      // Context prompts\n      const playerRect = this.player.getBounds();\n      const nearTerminal = this.terminalZone && Phaser.Geom.Intersects.RectangleToRectangle(playerRect, this.terminalZone.getBounds());\n      const nearPortal = this.portal && Phaser.Geom.Intersects.RectangleToRectangle(playerRect, this.portal.getBounds());\n      // Expand dummy interaction to a radius around it instead of strict sprite-bounds overlap\n      const nearDummy = !!(this.dummy && (() => { const dx = this.player.x - this.dummy.x; const dy = this.player.y - this.dummy.y; const r = 72; return (dx * dx + dy * dy) <= (r * r); })());\n      if (nearTerminal) this.prompt.setText('E: Open Terminal');\n      else if (nearDummy) this.prompt.setText('E: Reset Dummy Damage/Effects');\n      else if (nearPortal) this.prompt.setText('E: Return to Hub');\n      else this.prompt.setText('Shooting Range');\n\n      if (this.inputMgr.pressedInteract) {\n        if (nearTerminal) this.openTerminalPanel?.();\n        if (nearDummy) {\n          this._dummyDamage = 0;\n          if (this.dummy?.active) {\n            const d = this.dummy;\n            d._igniteValue = 0; d._toxinValue = 0; d._stunValue = 0;\n            d._ignitedUntil = 0; d._toxinedUntil = 0; d._stunnedUntil = 0;\n            d._toxinPartial = 0;\n            try { if (d._igniteIndicator) { d._igniteIndicator.destroy(); } } catch (_) {}\n            try { if (d._toxinIndicator) { d._toxinIndicator.destroy(); } } catch (_) {}\n            try { if (d._stunIndicator) { d._stunIndicator.destroy(); } } catch (_) {}\n            d._igniteIndicator = null; d._toxinIndicator = null; d._stunIndicator = null;\n          }\n        }\n        if (nearPortal) {\n          try { this.gs.shootingRange = false; } catch (_) {}\n          this.gs.nextScene = SceneKeys.Hub;\n          SaveManager.saveToLocal(this.gs);\n          this.scene.start(SceneKeys.Hub);\n        }\n      }\n    }\n    // Track and update ammo registry on weapon change or capacity change\n    if (this._lastActiveWeapon !== this.gs.activeWeapon) {\n      this._lastActiveWeapon = this.gs.activeWeapon;\n      const cap = this.getActiveMagCapacity();\n      this.ensureAmmoFor(this._lastActiveWeapon, cap);\n      this.registry.set('ammoInMag', this.ammoByWeapon[this._lastActiveWeapon]);\n      this.registry.set('magSize', cap);\n    } else {\n      // Keep registry in sync in case mods/cores change capacity\n      const cap = this.getActiveMagCapacity();\n      this.ensureAmmoFor(this._lastActiveWeapon, cap, true);\n      this.registry.set('magSize', cap);\n      this.registry.set('ammoInMag', this.ammoByWeapon[this._lastActiveWeapon]);\n    }\n    // Update spread heat each frame based on whether player is holding fire\n    const dt = (this.game?.loop?.delta || 16.7) / 1000;\n    if (this._spreadHeat === undefined) this._spreadHeat = 0;\n    const rampPerSec = 0.7; // time to max ~1.4s holding\n    const coolPerSec = 1.2; // cool to 0 in ~0.8s\n    if (this.inputMgr.isLMBDown && !weapon.singleFire && !isRail && !isLaser) {\n      this._spreadHeat = Math.min(1, this._spreadHeat + rampPerSec * dt);\n    } else {\n      this._spreadHeat = Math.max(0, this._spreadHeat - coolPerSec * dt);\n    }\n    // Robust single-click detect: Phaser pointer.justDown or edge from previous frame\n    const ptr = this.inputMgr.pointer;\n    if (this._lmbWasDown === undefined) this._lmbWasDown = false;\n    const edgeDown = (!this._lmbWasDown) && !!ptr.isDown && ((ptr.buttons & 1) === 1);\n    const wantsClick = !!ptr.justDown || edgeDown;\n    if (isRail) {\n      this.handleRailgunCharge(this.time.now, weapon, ptr);\n    }\n    // Laser handling (continuous)\n    if (isLaser) {\n      this.handleLaser(this.time.now, weapon, ptr, dt);\n    }\n    const wantsShot = (!isRail && !isLaser) && (weapon.singleFire ? wantsClick : this.inputMgr.isLMBDown);\n    if (wantsShot && (!this.lastShot || this.time.now - this.lastShot > weapon.fireRateMs)) {\n      const cap = this.getActiveMagCapacity();\n      const wid = this.gs.activeWeapon;\n      this.ensureAmmoFor(wid, cap);\n      const ammo = this.ammoByWeapon[wid] ?? 0;\n      if (ammo <= 0 || this.reload.active) {\n        // Start auto-reload when empty (or continue if already reloading)\n        if (!this.reload.active) {\n          this.reload.active = true;\n          this.reload.duration = this.getActiveReloadMs();\n          this.reload.until = this.time.now + this.reload.duration;\n          this.registry.set('reloadActive', true);\n          this.registry.set('reloadProgress', 0);\n        }\n      } else {\n        this.shoot();\n        this.lastShot = this.time.now;\n        this.ammoByWeapon[wid] = Math.max(0, ammo - 1);\n        this.registry.set('ammoInMag', this.ammoByWeapon[wid]);\n        // Auto-reload for rocket launcher (mag size 1)\n        if (wid === 'rocket' && this.ammoByWeapon[wid] <= 0) {\n          if (!this.reload.active) {\n            this.reload.active = true;\n            this.reload.duration = this.getActiveReloadMs();\n            this.reload.until = this.time.now + this.reload.duration;\n            this.registry.set('reloadActive', true);\n            this.registry.set('reloadProgress', 0);\n          }\n        }\n      }\n    }\n    this._lmbWasDown = !!ptr.isDown;\n\n    // Swap weapons with Q\n    if (Phaser.Input.Keyboard.JustDown(this.inputMgr.keys.q)) {\n      // Prefer swapping between equipped weapon slots\n      const slots = this.gs.equippedWeapons || [];\n      const a = this.gs.activeWeapon;\n      if (slots[0] && slots[1]) {\n        this.gs.activeWeapon = a === slots[0] ? slots[1] : slots[0];\n      } else {\n        const owned = this.gs.ownedWeapons;\n        if (owned && owned.length) {\n          const idx = Math.max(0, owned.indexOf(a));\n          const next = owned[(idx + 1) % owned.length];\n          this.gs.activeWeapon = next;\n        }\n      // Cancel any in-progress reload on weapon swap\n      this.reload.active = false;\n      this.reload.duration = 0;\n      this.registry.set('reloadActive', false);\n      // Cancel rail charging/aim if any\n      try { if (this.rail?.charging) this.rail.charging = false; } catch (_) {}\n      this.endRailAim?.();\n      // Clear laser beam if present\n      try { this.laser?.g?.clear?.(); } catch (_) {}\n      }\n    }\n\n    // Manual reload (R)\n    if (Phaser.Input.Keyboard.JustDown(this.inputMgr.keys.r)) {\n      const cap = this.getActiveMagCapacity();\n      const wid = this.gs.activeWeapon;\n      this.ensureAmmoFor(wid, cap);\n      if (!weapon.isLaser && !this.reload.active && (this.ammoByWeapon[wid] ?? 0) < cap) {\n        this.reload.active = true;\n        this.reload.duration = this.getActiveReloadMs();\n        this.reload.until = this.time.now + this.reload.duration;\n        this.registry.set('reloadActive', true);\n        this.registry.set('reloadProgress', 0);\n      }\n      // For laser: allow manual cooldown cancel if overheated\n      if (weapon.isLaser && this.laser?.overheat) {\n        // no-op: keep forced cooldown\n      }\n    }\n\n    // Ability activation (F)\n    if (this.inputMgr.pressedAbility) {\n      const nowT = this.time.now;\n      if (nowT >= (this.ability.onCooldownUntil || 0)) {\n        const abilityId = this.gs?.abilityId || 'ads';\n        if (abilityId === 'ads') {\n          this.deployADS();\n          this.ability.cooldownMs = 10000;\n          this.ability.onCooldownUntil = nowT + this.ability.cooldownMs;\n        } else if (abilityId === 'bits') {\n          this.deployBITs();\n          this.ability.cooldownMs = 10000;\n          this.ability.onCooldownUntil = nowT + this.ability.cooldownMs;\n        } else if (abilityId === 'repulse') {\n          this.deployRepulsionPulse();\n          this.ability.cooldownMs = 5000; // 5s for Repulsion Pulse\n          this.ability.onCooldownUntil = nowT + this.ability.cooldownMs;\n        }\n      }\n    }\n\n    // Update active gadgets (ADS)\n    if (this._gadgets && this._gadgets.length) {\n      const nowT = this.time.now;\n      this._gadgets = this._gadgets.filter((g) => {\n        if (nowT >= (g.until || 0)) { try { g.g?.destroy(); } catch (_) {} return false; }\n        // Zap nearest enemy projectile within radius, at most 5/s\n        if (nowT >= (g.nextZapAt || 0)) {\n          const radius = g.radius || 120; const r2 = radius * radius;\n          let best = null; let bestD2 = Infinity;\n          const arrB = this.enemyBullets?.getChildren?.() || [];\n          const arrG = this.enemyGrenades?.getChildren?.() || [];\n          for (let i = 0; i < arrB.length; i += 1) {\n            const b = arrB[i]; if (!b?.active) continue;\n            const dx = b.x - g.x; const dy = b.y - g.y; const d2 = dx * dx + dy * dy;\n            if (d2 <= r2 && d2 < bestD2) { best = b; bestD2 = d2; }\n          }\n          for (let i = 0; i < arrG.length; i += 1) {\n            const b = arrG[i]; if (!b?.active) continue;\n            const dx = b.x - g.x; const dy = b.y - g.y; const d2 = dx * dx + dy * dy;\n            if (d2 <= r2 && d2 < bestD2) { best = b; bestD2 = d2; }\n          }\n          if (best) {\n            // Draw instant blue laser then destroy the projectile\n            try {\n              const lg = this.add.graphics();\n              lg.setDepth(9000);\n              lg.lineStyle(1, 0x66aaff, 1);\n              const sx = g.x, sy = g.y - 4;\n              lg.beginPath(); lg.moveTo(sx, sy); lg.lineTo(best.x, best.y); lg.strokePath();\n              lg.setAlpha(1);\n              try {\n                this.tweens.add({ targets: lg, alpha: 0, duration: 320, ease: 'Quad.easeOut', onComplete: () => { try { lg.destroy(); } catch (_) {} } });\n              } catch (_) {\n                this.time.delayedCall(320, () => { try { lg.destroy(); } catch (__ ) {} });\n              }\n              // Tiny blue particle at impact point\n              try { impactBurst(this, best.x, best.y, { color: 0x66aaff, size: 'small' }); } catch (_) {}\n              // Blue pixel spray at laser origin (shorter but much wider)\n              try { const ang = Phaser.Math.Angle.Between(sx, sy, best.x, best.y); pixelSparks(this, sx, sy, { angleRad: ang, count: 6, spreadDeg: 60, speedMin: 90, speedMax: 140, lifeMs: 110, color: 0x66aaff, size: 2, alpha: 0.9 }); } catch (_) {}\n            } catch (_) {}\n            try { best.destroy(); } catch (_) {}\n            g.nextZapAt = nowT + 100; // 10 per second\n          }\n        }\n        return true;\n      });\n    }\n\n    // Ability cooldown progress for UI\n    try {\n      const nowT2 = this.time.now;\n      const until = this.ability?.onCooldownUntil || 0;\n      const active = nowT2 < until;\n      const denom = this.ability?.cooldownMs || 10000;\n      const remaining = Math.max(0, until - nowT2);\n      const prog = active ? (1 - Math.min(1, remaining / denom)) : 1;\n      this.registry.set('abilityCooldownActive', active);\n    this.registry.set('abilityCooldownProgress', prog);\n    } catch (_) {}\n\n    // Ignite burn ticking (global): apply burn DPS to ignited enemies\n    this._igniteTickAccum = (this._igniteTickAccum || 0) + dt;\n    const burnTick = 0.1; // 10 Hz for smoothness without perf hit\n    if (this._igniteTickAccum >= burnTick) {\n      const step = this._igniteTickAccum; // accumulate any leftover\n      this._igniteTickAccum = 0;\n      const enemies = this.enemies?.getChildren?.() || [];\n      const burnDps = 30;\n      const dmg = Math.max(0, Math.round(burnDps * step));\n      const nowT = this.time.now;\n      for (let i = 0; i < enemies.length; i += 1) {\n        const e = enemies[i]; if (!e?.active) continue;\n        if (e._ignitedUntil && nowT < e._ignitedUntil) {\n          if (!e.isDummy) {\n            if (typeof e.hp !== 'number') e.hp = e.maxHp || 20;\n            e.hp -= dmg;\n            if (e.hp <= 0) this.killEnemy(e);\n          } else {\n            this._dummyDamage = (this._dummyDamage || 0) + dmg;\n          }\n          // maintain indicator position\n          if (e._igniteIndicator?.setPosition) {\n            try { e._igniteIndicator.setPosition(e.x, e.y - 14); } catch (_) {}\n          }\n        } else {\n          // hide indicator if present\n          if (e._igniteIndicator) { try { e._igniteIndicator.destroy(); } catch (_) {} e._igniteIndicator = null; }\n        }\n      }\n    }\n\n    // Toxin ticking (global): apply 3 DPS and manage indicator/disorientation window\n    this._toxinTickAccum = (this._toxinTickAccum || 0) + dt;\n    const toxinTick = 0.1;\n    if (this._toxinTickAccum >= toxinTick) {\n      const step = this._toxinTickAccum; this._toxinTickAccum = 0;\n      const dps = 3;\n      const nowT = this.time.now;\n      const enemies = this.enemies?.getChildren?.() || [];\n      for (let i = 0; i < enemies.length; i += 1) {\n        const e = enemies[i]; if (!e?.active) continue;\n        if (e._toxinedUntil && nowT < e._toxinedUntil) {\n          // Accumulate fractional toxin damage per-entity to avoid rounding-away low DPS\n          const prev = (e._toxinPartial || 0);\n          const inc = dps * step;\n          const total = prev + inc;\n          const dmgInt = Math.floor(total);\n          e._toxinPartial = total - dmgInt;\n          if (dmgInt > 0) {\n            if (e.isDummy) {\n              this._dummyDamage = (this._dummyDamage || 0) + dmgInt;\n            } else {\n              if (typeof e.hp !== 'number') e.hp = e.maxHp || 20;\n              e.hp -= dmgInt;\n              if (e.hp <= 0) this.killEnemy(e);\n            }\n          }\n          // Maintain indicator position\n          if (e._toxinIndicator?.setPosition) { try { e._toxinIndicator.setPosition(e.x, e.y - 18); } catch (_) {} }\n        } else {\n          // Cleanup indicator\n          if (e._toxinIndicator) { try { e._toxinIndicator.destroy(); } catch (_) {} e._toxinIndicator = null; }\n          // Reset partial accumulator when effect ends\n          e._toxinPartial = 0;\n        }\n      }\n    }\n\n    // Stun indicator maintenance (no DPS; ensures indicator position and cleanup)\n    this._stunTickAccum = (this._stunTickAccum || 0) + dt;\n    const stunTick = 0.1;\n    if (this._stunTickAccum >= stunTick) {\n      this._stunTickAccum = 0;\n      const nowT = this.time.now;\n      const enemies = this.enemies?.getChildren?.() || [];\n      for (let i = 0; i < enemies.length; i += 1) {\n        const e = enemies[i]; if (!e?.active) continue;\n        if (e._stunnedUntil && nowT < e._stunnedUntil) {\n          if (!e._stunIndicator) { e._stunIndicator = this.add.graphics(); try { e._stunIndicator.setDepth(9000); } catch (_) {} e._stunIndicator.fillStyle(0xffff33, 1).fillCircle(0, 0, 2); }\n          try { e._stunIndicator.setPosition(e.x, e.y - 22); } catch (_) {}\n        } else {\n          if (e._stunIndicator) { try { e._stunIndicator.destroy(); } catch (_) {} e._stunIndicator = null; }\n        }\n      }\n    }\n\n    // Update fire fields (ignite zones)\n    if (!this._ffTickAccum) this._ffTickAccum = 0;\n    this._ffTickAccum += dt;\n    const ffTick = 0.1;\n    if (this._ffTickAccum >= ffTick) {\n      const step = this._ffTickAccum; this._ffTickAccum = 0;\n      const ignitePerSec = 10; const igniteAdd = ignitePerSec * step;\n      const nowT = this.time.now;\n      this._firefields = (this._firefields || []).filter((f) => {\n        if (nowT >= f.until) { try { f.g?.destroy(); } catch (_) {} try { f.pm?.destroy(); } catch (_) {} return false; }\n        // Visual flicker/pulse + redraw\n        try {\n          f._pulse = (f._pulse || 0) + step;\n          const pulse = 0.9 + 0.2 * Math.sin(f._pulse * 6.0);\n          const jitter = Phaser.Math.Between(-2, 2);\n          const r0 = Math.max(4, Math.floor(f.r * 0.50 * pulse));\n          const r1 = Math.max(6, Math.floor(f.r * 0.85 + jitter));\n          f.g.clear();\n          f.g.fillStyle(0xff6622, 0.22).fillCircle(f.x, f.y, r0);\n          f.g.fillStyle(0xffaa33, 0.14).fillCircle(f.x, f.y, r1);\n          f.g.lineStyle(2, 0xffaa33, 0.45).strokeCircle(f.x, f.y, f.r + jitter);\n        } catch (_) {}\n        // Orange pixel sparks rising from the field (railgun/muzzle-style particles)\n        try {\n          if (!f._sparkAt || nowT >= f._sparkAt) {\n            f._sparkAt = nowT + Phaser.Math.Between(40, 80);\n            for (let i = 0; i < 2; i += 1) {\n              const a = Phaser.Math.FloatBetween(0, Math.PI * 2);\n              const rr = Phaser.Math.FloatBetween(0, f.r * 0.7);\n              const px = f.x + Math.cos(a) * rr;\n              const py = f.y + Math.sin(a) * rr;\n              pixelSparks(this, px, py, { angleRad: -Math.PI / 2, count: 1, spreadDeg: 24, speedMin: 50, speedMax: 110, lifeMs: 200, color: 0xffaa66, size: 2, alpha: 0.95 });\n            }\n          }\n        } catch (_) {}\n        // Tick ignite within radius\n        const r2 = f.r * f.r; const arr = this.enemies?.getChildren?.() || [];\n        for (let i = 0; i < arr.length; i += 1) {\n          const e = arr[i]; if (!e?.active) continue;\n          const dx = e.x - f.x; const dy = e.y - f.y; if ((dx * dx + dy * dy) <= r2) {\n            e._igniteValue = Math.min(10, (e._igniteValue || 0) + igniteAdd);\n            if ((e._igniteValue || 0) >= 10) {\n              e._ignitedUntil = nowT + 2000; // refresh while inside\n              e._igniteValue = 0; // reset on trigger\n              if (!e._igniteIndicator) { e._igniteIndicator = this.add.graphics(); try { e._igniteIndicator.setDepth(9000); } catch (_) {} e._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2); }\n              try { e._igniteIndicator.setPosition(e.x, e.y - 14); } catch (_) {}\n            }\n          }\n        }\n        return true;\n      });\n    }\n\n    // Update Repulsion Pulse effects (block enemy projectiles and push enemies)\n    if (this._repulses && this._repulses.length) {\n      const dt2 = (this.game?.loop?.delta || 16.7) / 1000;\n      this._repulses = this._repulses.filter((rp) => {\n        rp.r += rp.speed * dt2;\n        try {\n          rp.g.clear();\n          rp.g.setBlendMode?.(Phaser.BlendModes.ADD);\n          // Trail cache of previous radii for drag effect\n          const now = this.time.now;\n          if (rp._lastTrailR === undefined) rp._lastTrailR = 0;\n          if (!rp._trail) rp._trail = [];\n          if ((rp.r - rp._lastTrailR) > 10) { rp._trail.push({ r: rp.r, t: now }); rp._lastTrailR = rp.r; }\n          // Keep last few rings\n          while (rp._trail.length > 6) rp._trail.shift();\n          // Draw trail rings (older = fainter)\n          for (let i = 0; i < rp._trail.length; i += 1) {\n            const it = rp._trail[i];\n            const age = (now - it.t) / 300; // 0..~\n            const a = Math.max(0, 0.22 * (1 - Math.min(1, age)));\n            if (a <= 0) continue;\n            rp.g.lineStyle(6, 0xffaa33, a).strokeCircle(0, 0, it.r);\n          }\n          // Current ring: bright thin edge + faint outer halo\n          rp.g.lineStyle(8, 0xffaa33, 0.20).strokeCircle(0, 0, rp.r);\n          rp.g.lineStyle(3, 0xffdd88, 0.95).strokeCircle(0, 0, Math.max(1, rp.r - 1));\n          // Periodic sparks along the band (denser for a lively pulse)\n          if (!rp._nextSparkAt) rp._nextSparkAt = now;\n          if (now >= rp._nextSparkAt) {\n            const sparks = 8;\n            for (let s = 0; s < sparks; s += 1) {\n              const a = Phaser.Math.FloatBetween(0, Math.PI * 2);\n              const sx = rp.x + Math.cos(a) * rp.r;\n              const sy = rp.y + Math.sin(a) * rp.r;\n              try { pulseSpark(this, sx, sy, { color: 0xffaa66, size: 2, life: 180 }); } catch (_) {}\n              try { pixelSparks(this, sx, sy, { angleRad: a, count: 1, spreadDeg: 6, speedMin: 90, speedMax: 160, lifeMs: 160, color: 0xffaa33, size: 2, alpha: 0.8 }); } catch (_) {}\n            }\n            rp._nextSparkAt = now + 28; // faster cadence\n          }\n        } catch (_) {}\n        const band = rp.band;\n        const r2min = (rp.r - band) * (rp.r - band);\n        const r2max = (rp.r + band) * (rp.r + band);\n        // Block enemy bullets in the band\n        try {\n          const arrB = this.enemyBullets?.getChildren?.() || [];\n          for (let i = 0; i < arrB.length; i += 1) {\n            const b = arrB[i]; if (!b?.active) continue; const dx = b.x - rp.x; const dy = b.y - rp.y; const d2 = dx * dx + dy * dy;\n            if (d2 >= r2min && d2 <= r2max) { try { impactBurst(this, b.x, b.y, { color: 0xffaa33, size: 'small' }); } catch (_) {} try { b.destroy(); } catch (_) {} }\n          }\n        } catch (_) {}\n        // Push enemies and apply 5 dmg once per enemy per pulse\n        try {\n          if (!rp._hitSet) rp._hitSet = new Set();\n          if (!rp._pushedSet) rp._pushedSet = new Set();\n          const arrE = this.enemies?.getChildren?.() || [];\n          for (let i = 0; i < arrE.length; i += 1) {\n            const e = arrE[i]; if (!e?.active) continue;\n            // If already pushed by this pulse, skip entirely; also skip while under any active knockback window\n            const nowPush = this.time.now;\n            if (rp._pushedSet.has(e)) continue;\n            if (nowPush < (e._repulseUntil || 0)) continue;\n            const dx = e.x - rp.x; const dy = e.y - rp.y; const d2 = dx * dx + dy * dy; if (d2 >= r2min && d2 <= r2max) {\n              const d = Math.sqrt(d2) || 1; const nx = dx / d; const ny = dy / d; const power = 240;\n              // Apply 1s knockback velocity; let physics/barricades handle collisions\n              if (!e.isDummy) {\n                e._repulseUntil = nowPush + 1000;\n                e._repulseVX = nx * power; e._repulseVY = ny * power;\n                try { e.body?.setVelocity?.(e._repulseVX, e._repulseVY); } catch (_) { try { e.setVelocity(e._repulseVX, e._repulseVY); } catch (_) {} }\n              }\n              // Mark this enemy as pushed for this pulse so re-contacts do not refresh/pile up\n              rp._pushedSet.add(e);\n              if (!rp._hitSet.has(e)) {\n                rp._hitSet.add(e);\n                if (e.isDummy) { this._dummyDamage = (this._dummyDamage || 0) + 5; }\n                else {\n                  if (typeof e.hp !== 'number') e.hp = e.maxHp || 20;\n                  e.hp -= 5;\n                  if (e.hp <= 0) { try { this.killEnemy(e); } catch (_) {} }\n                }\n              }\n            }\n          }\n        } catch (_) {}\n        if (rp.r >= rp.maxR) { try { rp.g.destroy(); } catch (_) {} return false; }\n        return true;\n      });\n    }\n\n    // Update BIT units\n    if (!this._bits) this._bits = [];\n    if (this._bits.length) {\n      const dt = (this.game?.loop?.delta || 16.7) / 1000;\n      const now = this.time.now;\n      const enemiesArr = this.enemies?.getChildren?.() || [];\n      this._bits = this._bits.filter((bit) => {\n        // Expire: return to player then disappear\n        if (now >= (bit.despawnAt || 0)) {\n          // Return-to-player phase: despawn immediately on contact\n          let dx = this.player.x - bit.x; let dy = this.player.y - bit.y;\n          let len = Math.hypot(dx, dy) || 1;\n          if (len < 12) { try { bit.g.destroy(); } catch (_) {} try { bit._thr?.destroy?.(); } catch (_) {} return false; }\n          const sp = 420;\n          bit.vx = (dx / len) * sp; bit.vy = (dy / len) * sp;\n          bit.x += bit.vx * dt; bit.y += bit.vy * dt;           try { bit.g.setPosition(bit.x, bit.y); } catch (_) {}\n          // Smooth sprite rotation to reduce jitter while hovering\n          try {\n            const targetAng = (trg ? Math.atan2(trg.y - bit.y, trg.x - bit.x) + Math.PI : Math.atan2(bit.vy, bit.vx));\n            bit._rot = (typeof bit._rot === 'number') ? Phaser.Math.Angle.RotateTo(bit._rot, targetAng, Phaser.Math.DegToRad(12)) : targetAng;\n            bit.g.setRotation(bit._rot);\n          } catch (_) {}\n          // Thruster draw\n          try {\n            const g = bit._thr; if (g) {\n              const vx = bit.vx || 0, vy = bit.vy || 0; const spd = Math.hypot(vx, vy) || 0; g.clear();\n              if (spd > 40) {\n                const tAng = Math.atan2(vy, vx);\n                bit._thrAng = (typeof bit._thrAng === 'number') ? Phaser.Math.Angle.RotateTo(bit._thrAng, tAng, Phaser.Math.DegToRad(10)) : tAng;\n                const ux = Math.cos(bit._thrAng), uy = Math.sin(bit._thrAng);\n                const tail = 8, stub = 4;\n                const tx = bit.x - ux * tail, ty = bit.y - uy * tail;\n                const sx2 = bit.x - ux * stub, sy2 = bit.y - uy * stub;\n                try { const back = tAng + Math.PI; const ex = bit.x + Math.cos(back) * 6; const ey = bit.y + Math.sin(back) * 6; pixelSparks(this, ex, ey, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); } catch (_) {}\n                // removed static blue thruster lines (use particles only)\n                // Yellow compact thruster particles (smaller/shorter)\n                try { const back = tAng + Math.PI; const ex = bit.x + Math.cos(back) * 6; const ey = bit.y + Math.sin(back) * 6; pixelSparks(this, ex, ey, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); } catch (_) {}\n              }\n            }\n          } catch (_) {}\n          dx = this.player.x - bit.x; dy = this.player.y - bit.y; len = Math.hypot(dx, dy) || 1;\n          if (len < 12) { try { bit.g.destroy(); } catch (_) {} try { bit._thr?.destroy?.(); } catch (_) {} return false; }\n          return true;\n        }\n        // Spawn scatter animation: keep initial outward motion briefly before any idle/lock logic\n        if (bit.spawnScatterUntil && now < bit.spawnScatterUntil) {\n          bit.x += (bit.vx || 0) * dt; bit.y += (bit.vy || 0) * dt;           try { bit.g.setPosition(bit.x, bit.y); } catch (_) {}\n          // Smooth rotation during scatter\n          try {\n            const targetAng = (trg ? Math.atan2(trg.y - bit.y, trg.x - bit.x) + Math.PI : Math.atan2((bit.vy || 0), (bit.vx || 0)));\n            bit._rot = (typeof bit._rot === 'number') ? Phaser.Math.Angle.RotateTo(bit._rot, targetAng, Phaser.Math.DegToRad(14)) : targetAng;\n            bit.g.setRotation(bit._rot);\n          } catch (_) {}\n          // Thruster draw\n          try {\n            const g = bit._thr; if (g) {\n              const vx = bit.vx || 0, vy = bit.vy || 0; const spd = Math.hypot(vx, vy) || 0; g.clear();\n              if (spd > 40) {\n                const tAng = Math.atan2(vy, vx);\n                bit._thrAng = (typeof bit._thrAng === 'number') ? Phaser.Math.Angle.RotateTo(bit._thrAng, tAng, Phaser.Math.DegToRad(10)) : tAng;\n                const ux = Math.cos(bit._thrAng), uy = Math.sin(bit._thrAng);\n                // removed static blue thruster lines (use particles only)\n                try { const back = tAng + Math.PI; const ex = bit.x + Math.cos(back) * 6; const ey = bit.y + Math.sin(back) * 6; pixelSparks(this, ex, ey, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); } catch (_) {}\n              }\n            }\n          } catch (_) {}\n          return true;\n        }\n        // Acquire or validate target (short lock range)\n        const lockR = 180; const lockR2 = lockR * lockR;\n        if (!bit.target || !bit.target.active) {\n          // nearest enemy within lock range only\n          let best = null; let bestD2 = Infinity;\n          for (let i = 0; i < enemiesArr.length; i += 1) {\n            const e = enemiesArr[i]; if (!e?.active) continue;\n            const dx = e.x - bit.x; const dy = e.y - bit.y; const d2 = dx * dx + dy * dy;\n            if (d2 <= lockR2 && d2 < bestD2) { best = e; bestD2 = d2; }\n          }\n          bit.target = best;\n        } else {\n          // Drop target if it moved out of lock range\n          const dx = bit.target.x - bit.x; const dy = bit.target.y - bit.y; const d2 = dx * dx + dy * dy;\n          if (d2 > lockR2) bit.target = null;\n        }\n        const trg = bit.target;\n        if (!trg) {\n          // Idle: hover closely around the player in a small orbit until a target enters lock range\n          if (bit._idleAngle === undefined) bit._idleAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n          if (bit._idleRadius === undefined) bit._idleRadius = Phaser.Math.Between(28, 48);\n          if (bit._idleSpeed === undefined) bit._idleSpeed = Phaser.Math.FloatBetween(2.0, 3.2); // rad/s\n          bit._idleAngle += bit._idleSpeed * dt;\n          const px = this.player.x; const py = this.player.y;\n          const tx = px + Math.cos(bit._idleAngle) * bit._idleRadius;\n          const ty = py + Math.sin(bit._idleAngle) * bit._idleRadius;\n          const dx = tx - bit.x; const dy = ty - bit.y; const len = Math.hypot(dx, dy) || 1;\n          const sp = 260;\n          bit.vx = (dx / len) * sp; bit.vy = (dy / len) * sp;\n          bit.x += bit.vx * dt; bit.y += bit.vy * dt;\n          try { bit.g.setPosition(bit.x, bit.y); } catch (_) {}\n          // In idle, face along orbit tangent to avoid jitter from small velocity changes\n          try {\n            const tangent = Math.atan2(ty - py, tx - px) + Math.PI / 2;\n            bit._rot = (typeof bit._rot === 'number') ? Phaser.Math.Angle.RotateTo(bit._rot, tangent, Phaser.Math.DegToRad(12)) : tangent;\n            bit.g.setRotation(bit._rot);\n          } catch (_) {}\n          // Thruster tail aligned with facing (single-sided)\n          try {\n            const g = bit._thr; if (g) {\n              g.clear();\n              const ux = Math.cos(bit._rot), uy = Math.sin(bit._rot);\n              const tail = 8, stub = 4;\n              const tx2 = bit.x - ux * tail, ty2 = bit.y - uy * tail;\n              const sx2 = bit.x - ux * stub, sy2 = bit.y - uy * stub;\n                try { const back = tAng + Math.PI; pixelSparks(this, bit.x, bit.y, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); } catch (_) {}\n              // Only yellow compact thruster particles in idle orbit\n              try { const back = bit._rot + Math.PI; const ex = bit.x + Math.cos(back) * 6; const ey = bit.y + Math.sin(back) * 6; pixelSparks(this, ex, ey, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); } catch (_) {}\n            }\n          } catch (_) {}\n          return true;\n        }\n        // Firing hold\n        if (now < (bit.holdUntil || 0)) {\n          // stay still; face target if present\n          if (trg) { try { bit.g.setRotation(Math.atan2(trg.y - bit.y, trg.x - bit.x) + Math.PI); } catch (_) {} }\n          // emit compact yellow thruster while attacking (opposite the laser/enemy direction)\n          try {\n            const laserAng = trg ? Math.atan2(trg.y - bit.y, trg.x - bit.x) : Math.atan2(bit.vy || 0, bit.vx || 0);\n            const back = laserAng + Math.PI;\n            { const ex = bit.x + Math.cos(back) * 6; const ey = bit.y + Math.sin(back) * 6; pixelSparks(this, ex, ey, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); }\n          } catch (_) {}\n          return true;\n        }\n        // Decide next action\n        if (!bit.moveUntil || now >= bit.moveUntil) {\n          // Either fire (if in range) or choose a new dash around target\n          const fireR = 180; const fireR2 = fireR * fireR;\n          const ddx = trg.x - bit.x; const ddy = trg.y - bit.y; const dd2 = ddx * ddx + ddy * ddy;\n          if ((!bit.lastShotAt || (now - bit.lastShotAt > 500)) && dd2 <= fireR2) {\n            // Fire: draw laser and damage\n            try {\n              const lg = this.add.graphics(); lg.setDepth(9000);\n              lg.lineStyle(1, 0x66aaff, 1);\n              lg.beginPath(); lg.moveTo(bit.x, bit.y); lg.lineTo(trg.x, trg.y); lg.strokePath();\n              this.tweens.add({ targets: lg, alpha: 0, duration: 320, ease: 'Quad.easeOut', onComplete: () => { try { lg.destroy(); } catch (_) {} } });\n            } catch (_) {}\n            // Blue pixel spray at bit laser origin (shorter, much wider, and more intense)\n            try { const ang = Phaser.Math.Angle.Between(bit.x, bit.y, trg.x, trg.y); pixelSparks(this, bit.x, bit.y, { angleRad: ang, count: 12, spreadDeg: 70, speedMin: 110, speedMax: 200, lifeMs: 110, color: 0x66aaff, size: 2, alpha: 0.95 }); } catch (_) {}\n            try { impactBurst(this, trg.x, trg.y, { color: 0x66aaff, size: 'small' }); } catch (_) {}\n            try { bit.g.setRotation(Math.atan2(trg.y - bit.y, trg.x - bit.x) + Math.PI); } catch (_) {}\n            // Apply damage (count on dummy instead of reducing HP)\n            if (trg.isDummy) {\n              this._dummyDamage = (this._dummyDamage || 0) + 7;\n            } else {\n              if (typeof trg.hp !== 'number') trg.hp = trg.maxHp || 20;\n              trg.hp -= 7; if (trg.hp <= 0) { try { this.killEnemy(trg); } catch (_) {} }\n            }\n            bit.lastShotAt = now;\n            bit.holdUntil = now + 400; // hold for 0.4s\n            bit.moveUntil = now + 400; // next plan after hold\n            return true;\n          }\n          // Plan a quick straight movement around target\n          const angTo = Math.atan2(bit.y - trg.y, bit.x - trg.x);\n          const off = Phaser.Math.FloatBetween(-Math.PI / 2, Math.PI / 2);\n          const r = Phaser.Math.Between(40, 120);\n          const tx = trg.x + Math.cos(angTo + off) * r;\n          const ty = trg.y + Math.sin(angTo + off) * r;\n          const dx = tx - bit.x; const dy = ty - bit.y; const len = Math.hypot(dx, dy) || 1;\n          const sp = 380; bit.vx = (dx / len) * sp; bit.vy = (dy / len) * sp;\n          bit.moveUntil = now + Phaser.Math.Between(240, 420);\n        } else {\n          // Move step\n          bit.x += bit.vx * dt; bit.y += bit.vy * dt;          try { bit.g.setPosition(bit.x, bit.y); } catch (_) {}\n          try {\n            const targetAng = (trg ? Math.atan2(trg.y - bit.y, trg.x - bit.x) + Math.PI : Math.atan2(bit.vy, bit.vx));\n            bit._rot = (typeof bit._rot === 'number') ? Phaser.Math.Angle.RotateTo(bit._rot, targetAng, Phaser.Math.DegToRad(12)) : targetAng;\n            bit.g.setRotation(bit._rot);\n          } catch (_) {}\n          // Thruster draw\n          try {\n            const g = bit._thr; if (g) {\n              const vx = bit.vx || 0, vy = bit.vy || 0; const spd = Math.hypot(vx, vy) || 0; g.clear();\n              if (spd > 40) {\n                const tAng = Math.atan2(vy, vx);\n                bit._thrAng = (typeof bit._thrAng === 'number') ? Phaser.Math.Angle.RotateTo(bit._thrAng, tAng, Phaser.Math.DegToRad(10)) : tAng;\n                const ux = Math.cos(bit._thrAng), uy = Math.sin(bit._thrAng);\n                const tail = 8, stub = 4; const tx = bit.x - ux * tail, ty = bit.y - uy * tail; const sx2 = bit.x - ux * stub, sy2 = bit.y - uy * stub;\n                try { const back = tAng + Math.PI; const ex = bit.x + Math.cos(back) * 6; const ey = bit.y + Math.sin(back) * 6; pixelSparks(this, ex, ey, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); } catch (_) {}\n                // particles-only thruster (remove static blue lines)\r\n                try { const back = tAng + Math.PI; pixelSparks(this, bit.x, bit.y, { angleRad: back, count: 1, spreadDeg: 4, speedMin: 60, speedMax: 110, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 }); } catch (_) {}\n              }\n            }\n          } catch (_) {}\n        }\n        return true;\n      });\n    }\n\n    // Update WASP BITS (armour-driven, persistent)\n    const hasWaspArmour = (this.gs?.armour?.id === 'wasp_bits');\n    if (!hasWaspArmour) {\n      // Clean up if armour unequipped\n      if (this._wasps && this._wasps.length) {\n        try { this._wasps.forEach((w) => { try { w?.g?.destroy?.(); } catch (_) {} try { w?._thr?.destroy?.(); } catch (_) {} }); } catch (_) {}\n        this._wasps = [];\n      }\n    } else {\n      if (!this._wasps) this._wasps = [];\n      // Ensure exactly 2 wasps exist\n      const need = 2 - this._wasps.length;\n      for (let i = 0; i < need; i += 1) {\n        const g = createFittedImage(this, this.player.x, this.player.y, 'ability_bit', 14);\n        try { g.setDepth(9000); g.setTint(0xffff66); } catch (_) {}\n        const w = { x: this.player.x, y: this.player.y, vx: 0, vy: 0, g,\n          state: 'idle', target: null,\n          hoverUntil: 0, dashUntil: 0, lastDashAt: 0, dashHit: false, didFinalDash: false,\n          _hoverAngle: Phaser.Math.FloatBetween(0, Math.PI * 2), _hoverR: Phaser.Math.Between(16, 36), _hoverChangeAt: 0 };\n        try { w._thr = this.add.graphics(); w._thr.setDepth(8800); w._thr.setBlendMode?.(Phaser.BlendModes.ADD); } catch (_) {}\n        this._wasps.push(w);\n      }\n      // Update each wasp\n      if (this._wasps.length) {\n        const dt = (this.game?.loop?.delta || 16.7) / 1000;\n        const now = this.time.now;\n        // Reduced detection radius per request\n        const detectR = 160; const detectR2 = detectR * detectR;\n        const enemiesArr = this.enemies?.getChildren?.() || [];\n        this._wasps = this._wasps.filter((w) => {\n          if (!w?.g?.active) { try { w?._thr?.destroy?.(); } catch (_) {} return false; }\n          // Acquire/validate target based on player-centric radius\n          if (!w.target || !w.target.active) {\n            w.target = null; w.didFinalDash = false;\n            let best = null; let bestD2 = Infinity;\n            for (let i = 0; i < enemiesArr.length; i += 1) {\n              const e = enemiesArr[i]; if (!e?.active) continue; if (e.isBoss) continue;\n              const dxp = e.x - this.player.x; const dyp = e.y - this.player.y; const d2p = dxp * dxp + dyp * dyp;\n              if (d2p <= detectR2) {\n                const dx = e.x - w.x; const dy = e.y - w.y; const d2 = dx * dx + dy * dy;\n                if (d2 < bestD2) { best = e; bestD2 = d2; }\n              }\n            }\n            w.target = best;\n          } else {\n            const dxp = w.target.x - this.player.x; const dyp = w.target.y - this.player.y; const d2p = dxp * dxp + dyp * dyp;\n            if (d2p > detectR2) {\n              // Target left detection radius: mark for one final dash\n              if (!w.didFinalDash) {\n                // will be handled by dash planner below\n              } else {\n                w.target = null; w.state = 'idle'; w.didFinalDash = false;\n              }\n            }\n          }\n\n          const t = w.target;\n          // Dash update when active (straight line)\n          if (w.state === 'dashing') {\n            const px = w.x; const py = w.y;\n            w.x += (w.vx || 0) * dt; w.y += (w.vy || 0) * dt; try { w.g.setPosition(w.x, w.y); } catch (_) {}\n            try { w.g.setRotation(Math.atan2(w.y - py, w.x - px) + Math.PI); } catch (_) {}\n            // Thruster while dashing as well (subtle)\n            try { const g = w._thr; if (g) { g.clear(); const vx = w.vx || 0, vy = w.vy || 0; const spd = Math.hypot(vx, vy) || 1; const ux = vx / spd, uy = vy / spd; const tail = 10; const stub = 5; const tx = w.x - ux * tail; const ty = w.y - uy * tail; const sx = w.x - ux * stub; const sy = w.y - uy * stub; try { const g = w._thr; if (g) { g.clear(); } } catch (_) {} } } catch (_) {}\n            // Yellow compact thruster particles behind WASP bit while dashing (emit from rear with smoothing)\n            try {\n              const sp2 = (w.vx||0)*(w.vx||0) + (w.vy||0)*(w.vy||0);\n              const desired = (sp2 > 1) ? (Math.atan2(w.vy || 0, w.vx || 0) + Math.PI) : ((w._rot || 0) + Math.PI);\n              w._thrBackAng = (typeof w._thrBackAng === 'number') ? Phaser.Math.Angle.RotateTo(w._thrBackAng, desired, Phaser.Math.DegToRad(12)) : desired;\n              const ex = w.x + Math.cos(w._thrBackAng) * 6;\n              const ey = w.y + Math.sin(w._thrBackAng) * 6;\n              pixelSparks(this, ex, ey, { angleRad: w._thrBackAng, count: 1, spreadDeg: 4, speedMin: 70, speedMax: 120, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 });\n            } catch (_) {}\n            // Ensure visible blue spark trail as fallback\n            if (!w._lastSparkAt || (now - w._lastSparkAt) >= 20) {\n              try { pulseSpark(this, w.x, w.y, { color: 0x66aaff, size: 2, life: 140 }); } catch (_) {}\n              w._lastSparkAt = now;\n            }\n            // Fading blue line segment along dash path\n            try {\n              if (!w._lastLineAt || (now - w._lastLineAt) >= 16) {\n                const lg = this.add.graphics();\n                try { lg.setDepth(9850); lg.setBlendMode?.(Phaser.BlendModes.ADD); } catch (_) {}\n                lg.lineStyle(2, 0x66aaff, 0.95);\n                lg.beginPath(); lg.moveTo(px, py); lg.lineTo(w.x, w.y); lg.strokePath();\n                this.tweens.add({ targets: lg, alpha: 0, duration: 240, ease: 'Quad.easeOut', onComplete: () => { try { lg.destroy(); } catch (_) {} } });\n                w._lastLineAt = now;\n              }\n            } catch (_) {}\n            // Hit check\n            if (t && t.active && !w.dashHit) {\n              const dx = t.x - w.x; const dy = t.y - w.y; const len = Math.hypot(dx, dy) || 1;\n              if (len < 14) {\n              // Apply damage and stun\n              if (t.isDummy) {\n                  this._dummyDamage = (this._dummyDamage || 0) + 3.5;\n                  // Stun build-up for dummy as well\n                  t._stunValue = Math.min(10, (t._stunValue || 0) + 2.5);\n                  if ((t._stunValue || 0) >= 10) {\n                    t._stunnedUntil = now + 200;\n                    t._stunValue = 0; // reset on trigger\n                    if (!t._stunIndicator) { t._stunIndicator = this.add.graphics(); try { t._stunIndicator.setDepth(9000); } catch (_) {} t._stunIndicator.fillStyle(0xffff33, 1).fillCircle(0, 0, 2); }\n                    try { t._stunIndicator.setPosition(t.x, t.y - 22); } catch (_) {}\n                  }\n                } else {\n                  if (typeof t.hp !== 'number') t.hp = t.maxHp || 20;\n                  t.hp -= 3.5; if (t.hp <= 0) { this.killEnemy(t); }\n                  // Stun build-up: +2.5 per hit, stun at 10 (0.2s), applies to all (boss too)\n                  t._stunValue = Math.min(10, (t._stunValue || 0) + 2.5);\n                  if ((t._stunValue || 0) >= 10) {\n                    t._stunnedUntil = now + 200;\n                    t._stunValue = 0; // reset on trigger\n                    if (!t._stunIndicator) { t._stunIndicator = this.add.graphics(); try { t._stunIndicator.setDepth(9000); } catch (_) {} t._stunIndicator.fillStyle(0xffff33, 1).fillCircle(0, 0, 2); }\n                    try { t._stunIndicator.setPosition(t.x, t.y - 22); } catch (_) {}\n                    // Interrupt actions\n                    try { if (t.isSniper) { t.aiming = false; t._aimG?.clear?.(); t._aimG?.destroy?.(); t._aimG = null; } } catch (_) {}\n                    try { t._burstLeft = 0; } catch (_) {}\n                  }\n                }\n                w.dashHit = true;\n              }\n            }\n            if (now >= (w.dashUntil || 0)) {\n              // End dash\n              w.state = (t && t.active && (!w.didFinalDash)) ? 'locked' : 'idle';\n              if (t && t.active) {\n                const dxp = t.x - this.player.x; const dyp = t.y - this.player.y; const d2p = dxp * dxp + dyp * dyp;\n                if (d2p > detectR2) { w.target = null; w.didFinalDash = false; }\n              } else { w.target = null; w.didFinalDash = false; }\n              w.vx = 0; w.vy = 0; w.dashHit = false; w._dash = null; // do not snap back to original\n              // Stop and cleanup trail shortly after dash ends\n              try {\n                if (w._trailEmitter) { w._trailEmitter.on = false; }\n                if (w._trailMgr) {\n                  this.time.delayedCall(260, () => { try { w._trailMgr.destroy(); } catch (_) {} w._trailMgr = null; w._trailEmitter = null; });\n                }\n              } catch (_) {}\n              // Retain current offset around base to avoid snapping back\n              const bx = (t && t.active) ? t.x : this.player.x;\n              const by = (t && t.active) ? t.y : this.player.y;\n              const ox = w.x - bx; const oy = w.y - by;\n              const d = Math.hypot(ox, oy) || 1;\n              w._hoverR = Phaser.Math.Clamp(d, (t && t.active) ? 28 : 22, (t && t.active) ? 52 : 42);\n              w._hoverAngle = Math.atan2(oy, ox);\n              w._hoverChangeAt = now + Phaser.Math.Between(280, 560);\n            }\n            return true;\n          }\n\n          // Hover behavior (wasp-like jitter) around target or player\n          const baseX = t && t.active ? t.x : this.player.x;\n          const baseY = t && t.active ? t.y : this.player.y;\n          if (now >= (w._hoverChangeAt || 0)) {\n            w._hoverChangeAt = now + Phaser.Math.Between(220, 520);\n            // small random offset radius and angle step\n            const addR = Phaser.Math.Between(-6, 6);\n            w._hoverR = Phaser.Math.Clamp((w._hoverR || (t && t.active ? 32 : 26)) + addR, (t && t.active) ? 28 : 22, (t && t.active) ? 52 : 42);\n            w._hoverAngle += Phaser.Math.FloatBetween(-0.9, 0.9);\n          }\n          // Use larger hover distance when around a target vs around player\n          const baseR = t && t.active ? (w._hoverR || 32) : (w._hoverR || 26);\n          const hx = baseX + Math.cos(w._hoverAngle) * baseR;\n          const hy = baseY + Math.sin(w._hoverAngle) * baseR;\n          const dxh = hx - w.x; const dyh = hy - w.y; const llen = Math.hypot(dxh, dyh) || 1;\n          const hsp = t ? 320 : 280;\n          w.vx = (dxh / llen) * hsp; w.vy = (dyh / llen) * hsp;\n          w.x += w.vx * dt; w.y += w.vy * dt; try { w.g.setPosition(w.x, w.y); } catch (_) {}\n          // Smooth hover rotation\n          try { const tAng = Math.atan2(w.vy, w.vx); w._rot = (typeof w._rot === 'number') ? Phaser.Math.Angle.RotateTo(w._rot, tAng, Phaser.Math.DegToRad(12)) : tAng; w.g.setRotation(w._rot); } catch (_) {}\n          // Thruster draw (yellowish) with smoothing and speed threshold\n          try { const g = w._thr; if (g) { const vx = w.vx || 0, vy = w.vy || 0; const spd = Math.hypot(vx, vy) || 0; g.clear(); if (spd > 40) { const tAng2 = Math.atan2(vy, vx); w._thrAng = (typeof w._thrAng === 'number') ? Phaser.Math.Angle.RotateTo(w._thrAng, tAng2, Phaser.Math.DegToRad(10)) : tAng2; const ux = Math.cos(w._thrAng), uy = Math.sin(w._thrAng); const tail = 10, stub = 5; const tx = w.x - ux * tail, ty = w.y - uy * tail; const sx2 = w.x - ux * stub, sy2 = w.y - uy * stub; try { const g = w._thr; if (g) { g.clear(); } } catch (_) {} } } } catch (_) {}\n          // Yellow compact thruster particles during hover (emit from rear with smoothing; fallback to facing when nearly stationary)\n          try {\n            const sp2 = (w.vx||0)*(w.vx||0) + (w.vy||0)*(w.vy||0);\n            const base = (sp2 > 1) ? Math.atan2(w.vy || 0, w.vx || 0) : (w._rot || 0);\n            const desired = base + Math.PI;\n            w._thrBackAng = (typeof w._thrBackAng === 'number') ? Phaser.Math.Angle.RotateTo(w._thrBackAng, desired, Phaser.Math.DegToRad(12)) : desired;\n            const ex = w.x + Math.cos(w._thrBackAng) * 6;\n            const ey = w.y + Math.sin(w._thrBackAng) * 6;\n            pixelSparks(this, ex, ey, { angleRad: w._thrBackAng, count: 1, spreadDeg: 4, speedMin: 70, speedMax: 120, lifeMs: 50, color: 0xffee66, size: 1, alpha: 0.8 });\n          } catch (_) {}\n\n          // Plan dash when locked\n          if (t && t.active) {\n            const dxp = t.x - this.player.x; const dyp = t.y - this.player.y; const outOfRadius = (dxp * dxp + dyp * dyp) > detectR2;\n            // Increased dash cooldown\n            const dashReady = (!w.lastDashAt || (now - w.lastDashAt >= 900));\n            if (dashReady && (!outOfRadius || !w.didFinalDash)) {\n              // Start straight dash toward target, from varied approach angles and shorter range\n              const sx = w.x; const sy = w.y; const tx = t.x; const ty = t.y;\n              const dx0 = tx - sx; const dy0 = ty - sy; const baseAng = Math.atan2(dy0, dx0);\n              if (w._approachSign === undefined) w._approachSign = (Math.random() < 0.5 ? -1 : 1);\n              w._approachSign *= -1; // alternate sides each dash (opposite angle)\n              const angOff = Phaser.Math.FloatBetween(0.4, 0.7) * w._approachSign; // vary entry angle\n              const rOff = Phaser.Math.Between(10, 24); // aim near enemy, not center\n              let ex = tx + Math.cos(baseAng + angOff) * rOff;\n              let ey = ty + Math.sin(baseAng + angOff) * rOff;\n              // Randomize dash length and duration, with overall faster speed\n              let dx = ex - sx; let dy = ey - sy; let len = Math.hypot(dx, dy) || 1;\n              const minDashLen = 90; const maxDashLen = 140;\n              const desired = Math.min(len, Phaser.Math.Between(minDashLen, maxDashLen));\n              const ux = dx / len; const uy = dy / len; ex = sx + ux * desired; ey = sy + uy * desired; dx = ex - sx; dy = ey - sy; len = Math.hypot(dx, dy) || 1;\n              const dur = Phaser.Math.Between(90, 130); // randomized duration\n              const sp = ((len * 1000) / Math.max(1, dur)) * 1.2; // +20% speed boost\n              w.vx = (dx / len) * sp; w.vy = (dy / len) * sp;\n              w._dash = null;\n              w.dashUntil = now + dur; w.lastDashAt = now; w.state = 'dashing'; w.dashHit = false;\n              // Blue trail while dashing (more intense and visible)\n              try {\n                const texKey = 'bit_trail_particle_bold';\n                if (!this.textures || !this.textures.exists(texKey)) {\n                  const tg = this.make.graphics({ x: 0, y: 0, add: false });\n                  tg.clear(); tg.fillStyle(0x66aaff, 1); tg.fillCircle(7, 7, 7);\n                  tg.generateTexture(texKey, 14, 14); tg.destroy();\n                }\n                if (w._trailMgr) { try { w._trailMgr.destroy(); } catch (_) {} w._trailMgr = null; }\n                w._trailMgr = this.add.particles(texKey);\n                try { w._trailMgr.setDepth?.(9800); } catch (_) {}\n                const emitter = w._trailMgr.createEmitter({\n                  speed: { min: 0, max: 20 },\n                  lifespan: { min: 260, max: 420 },\n                  alpha: { start: 1.0, end: 0 },\n                  scale: { start: 1.0, end: 0.1 },\n                  quantity: 9,\n                  frequency: 6,\n                  tint: 0x66aaff,\n                  blendMode: Phaser.BlendModes.ADD,\n                });\n                try { emitter.startFollow(w.g); } catch (_) {}\n                w._trailEmitter = emitter;\n              } catch (_) {}\n              if (outOfRadius) w.didFinalDash = true; // one last dash then drop\n            }\n          }\n          return true;\n        });\n      }\n    }\n\n    // Player melee: C key, 150鎺? 48px, 10 dmg\n    try {\n      if (this.inputMgr?.pressedMelee) this.performPlayerMelee?.();\n    } catch (_) {}\n\n    // Rebuild nav grid periodically so enemies can re-route around obstacles\n    if (!this._nav) this._nav = { grid: null, builtAt: 0 };\n    if (!this._nav.grid || (this.time.now - this._nav.builtAt > 1200)) {\n      try {\n        this._nav.grid = buildNavGrid(this, this.arenaRect, 16);\n        this._nav.builtAt = this.time.now;\n      } catch (_) {}\n    }\n\n    // Update enemies: melee chase; shooters chase gently and fire at intervals; snipers aim then fire\n    this.enemies.getChildren().forEach((e) => {\n      if (!e.active) return;\n      if (e.isDummy) { try { e.body.setVelocity(0, 0); } catch (_) {} return; }\n      const now = this.time.now;\n      const dt = (this.game?.loop?.delta || 16.7) / 1000; // seconds\n      // Stun: freeze movement and actions during stun window\n      if (e._stunnedUntil && now < e._stunnedUntil) {\n        try { e.body?.setVelocity?.(0, 0); } catch (_) { try { e.setVelocity(0, 0); } catch (_) {} }\n        return;\n      }\n      // If under repulsion knockback, override movement for 1s to respect barricade physics\n      // Disorientation (toxin) overrides movement briefly\n      if (!e.isBoss && e._toxinedUntil && now < e._toxinedUntil) {\n        if (!e._wanderChangeAt || now >= e._wanderChangeAt) {\n          e._wanderChangeAt = now + Phaser.Math.Between(300, 700);\n          const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);\n          const mag = Phaser.Math.FloatBetween(0.3, 1.0);\n          e._wanderVX = Math.cos(ang) * e.speed * mag;\n          e._wanderVY = Math.sin(ang) * e.speed * mag;\n        }\n        const vx = e._wanderVX || 0; const vy = e._wanderVY || 0;\n        try { e.body?.setVelocity?.(vx, vy); } catch (_) { try { e.setVelocity(vx, vy); } catch (_) {} }\n        // Do not return; allow shooter logic to run while disoriented\n      }\n      if (now < (e._repulseUntil || 0)) {\n        const vx = e._repulseVX || 0; const vy = e._repulseVY || 0;\n        try { e.body?.setVelocity?.(vx, vy); } catch (_) { try { e.setVelocity(vx, vy); } catch (_) {} }\n        return;\n      }\n      const dx = this.player.x - e.x;\n      const dy = this.player.y - e.y;\n      const dist = Math.hypot(dx, dy) || 1;\n      const nx = dx / dist;\n      const ny = dy / dist;\n\n      // Movement logic by type\n      // Snipers: move like shooters when not aiming, freeze only during aim\n      if (!e.isSniper || (e.isSniper && !e.aiming)) {\n        let vx = 0, vy = 0;\n        let speed = e.speed || 60;\n        // Global speed boost for all enemies\n        speed *= 1.5;\n        // Rook: update and draw shield; turn slowly toward player (30掳/s)\n        if (e.isRook) {\n          try {\n            const targetAng = Math.atan2(dy, dx);\n            const maxTurn = Phaser.Math.DegToRad(30) * dt; // rad/s * dt\n            const cur = e._shieldAngle || 0;\n            const delta = Phaser.Math.Angle.Wrap(targetAng - cur);\n            const step = Phaser.Math.Clamp(delta, -maxTurn, maxTurn);\n            e._shieldAngle = cur + step;\n            if (!e._shieldG) { e._shieldG = this.add.graphics(); try { e._shieldG.setDepth(8500); e._shieldG.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {} }\n            const g = e._shieldG; const half = Phaser.Math.DegToRad(45);\n            const r = (e._shieldRadius || 60);\n          const gap = 35; const off = (gap - r);\n            const baseR = r;\n            const cx = e.x + Math.cos(e._shieldAngle) * off;\n            const cy = e.y + Math.sin(e._shieldAngle) * off;\n            // Match player shield VFX style: pulsing radius and alpha, two stroke layers\n            const t = ((this.time?.now || 0) % 1000) / 1000;\n            const radius = baseR + Math.sin(t * Math.PI * 2) * 1.0;\n            const p = 1; // no shield HP for enemies; use full visual strength\n            const alpha = (0.12 + 0.28 * p) + Math.sin(t * Math.PI * 2) * 0.04 * p;\n            try {\n              g.clear(); g.setPosition(cx, cy);\n              // Exact player shield style but as an arc and red palette\n              g.lineStyle(3, 0xff6666, 0.55 + 0.4 * p).beginPath(); g.arc(0, 0, radius, e._shieldAngle - half, e._shieldAngle + half, false); g.strokePath();\n              g.lineStyle(2, 0xff9999, 0.3 + 0.4 * p).beginPath(); g.arc(0, 0, Math.max(11, radius - 2.5), e._shieldAngle - half, e._shieldAngle + half, false); g.strokePath();\n              try { g.setAlpha(alpha); } catch (_) {}\n            } catch (_) {}\n\n            // Transparent red sector from Rook to arc (visual coverage area)\n            // Connector lines from Rook center to arc endpoints (transparent red)\n            try {\n              const rx = e.x - cx, ry = e.y - cy; // rook center in shield local coords\n              const a1 = e._shieldAngle - half; const a2 = e._shieldAngle + half;\n              const ex1 = Math.cos(a1) * radius, ey1 = Math.sin(a1) * radius;\n              const ex2 = Math.cos(a2) * radius, ey2 = Math.sin(a2) * radius;\n              g.lineStyle(1, 0xff3333, 0.22).beginPath(); g.moveTo(rx, ry); g.lineTo(ex1, ey1); g.strokePath();\n              g.lineStyle(1, 0xff3333, 0.22).beginPath(); g.moveTo(rx, ry); g.lineTo(ex2, ey2); g.strokePath();\n            } catch (_) {}\n\n                        try {\n              const r = (e._shieldRadius || 60);\n              const gap = 35; const off = (gap - r);\n              const cx = e.x + Math.cos(e._shieldAngle || 0) * off;\n              const cy = e.y + Math.sin(e._shieldAngle || 0) * off;\n              const zoneR = Math.max(8, Math.floor(r));\n              if (!e._shieldZone || !e._shieldZone.body) {\n                const z = this.add.zone(cx, cy, Math.ceil(zoneR * 2), Math.ceil(zoneR * 2));\n                this.physics.world.enable(z);\n                z.body.setAllowGravity(false);\n                z.body.setImmovable(true);\n                try { z.body.setCircle(zoneR); } catch (_) { try { z.body.setSize(Math.ceil(zoneR * 2), Math.ceil(zoneR * 2)); } catch (_) {} }\n                z._owner = e; e._shieldZone = z; this.rookShieldGroup.add(z);\n              } else {\n                const z = e._shieldZone; z.setPosition(cx, cy);\n                try { z.body.setCircle(zoneR); } catch (_) { try { z.body.setSize(Math.ceil(zoneR * 2), Math.ceil(zoneR * 2)); } catch (_) {} }\n              }\n            } catch (_) {}\n          } catch (_) {}\n        }\n        // Melee attack state machine (for base + runner + rook)\n        if (e.isMelee && !e.isShooter && !e.isSniper && !e.isGrenadier) {\n          let cfg = e.isRunner ? { range: 64, half: Phaser.Math.DegToRad(45), wind: 220, sweep: 120, recover: 380 } : { range: 56, half: Phaser.Math.DegToRad(45), wind: 350, sweep: 120, recover: 500 };\n          if (e.isRook) { cfg = { range: 90, half: Phaser.Math.DegToRad(45), wind: 380, sweep: 120, recover: 640 }; }\n          if (!e._mState) e._mState = 'idle';\n          // Enter windup if player close\n          if (e._mState === 'idle') {\n            if (dist <= (cfg.range + 8)) {\n              e._mState = 'windup'; e._meleeUntil = now + cfg.wind; e._meleeFacing = Math.atan2(dy, dx); e._meleeAlt = !e._meleeAlt;\n            }\n          }\n          // Freeze during windup\n          if (e._mState === 'windup') {\n            vx = 0; vy = 0;\n            if (now >= (e._meleeUntil || 0)) {\n              // Start sweep\n              e._mState = 'sweep'; e._meleeDidHit = false; e._meleeUntil = now + cfg.sweep;\n              try { this.spawnMeleeVfx(e, e._meleeFacing, 90, cfg.sweep, 0xff3333, cfg.range, e._meleeAlt); } catch (_) {}\n              // Schedule mid-sweep damage check at ~60ms\n              this.time.delayedCall(60, () => {\n                if (!e.active || e._mState !== 'sweep') return;\n                const pdx = this.player.x - e.x; const pdy = this.player.y - e.y;\n                const dd = Math.hypot(pdx, pdy) || 1;\n                const angP = Math.atan2(pdy, pdx);\n                const diff = Math.abs(Phaser.Math.Angle.Wrap(angP - (e._meleeFacing || 0)));\n                if (dd <= cfg.range && diff <= cfg.half && !e._meleeDidHit) {\n                  this.applyPlayerDamage((e.damage || 10));\n                  this.player.iframesUntil = this.time.now + 600;\n                  try { impactBurst(this, this.player.x, this.player.y, { color: 0xff3333, size: 'small' }); } catch (_) {}\n                  e._meleeDidHit = true;\n                  if (this.gs && this.gs.hp <= 0) {\n                    try {\n                      const eff = getPlayerEffects(this.gs);\n                      this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n                      this.gs.nextScene = SceneKeys.Hub;\n                      SaveManager.saveToLocal(this.gs);\n                      this.scene.start(SceneKeys.Hub);\n                    } catch (_) {}\n                    return;\n                  }\n                }\n              });\n            }\n          }\n          // During sweep, stand still\n          if (e._mState === 'sweep') {\n            vx = 0; vy = 0;\n            if (now >= (e._meleeUntil || 0)) {\n              e._mState = 'recover'; e._meleeUntil = now + cfg.recover; e._meleeSlowUntil = now + 280;\n            }\n          }\n          // Recovery: reduced movement speed, then back to idle\n          if (e._mState === 'recover') {\n            // Slowdown applied later to smoothed velocity\n            if (now >= (e._meleeUntil || 0)) { e._mState = 'idle'; }\n          }\n        }\n        // Pathfinding when LOS to player is blocked\n        let usingPath = false;\n        const losBlocked = this.isLineBlocked(e.x, e.y, this.player.x, this.player.y);\n        if (losBlocked && this._nav?.grid) {\n          const needRepath = (!e._path || (e._pathIdx == null) || (e._pathIdx >= e._path.length) || (now - (e._lastPathAt || 0) > ((e.isGrenadier && e._charging) ? 300 : 800)));\n          if (needRepath) {\n            try {\n              const [sgx, sgy] = worldToGrid(this._nav.grid, e.x, e.y);\n              const [ggx, ggy] = worldToGrid(this._nav.grid, this.player.x, this.player.y);\n              e._path = findPath(this._nav.grid, sgx, sgy, ggx, ggy) || null;\n              e._pathIdx = 0; e._lastPathAt = now;\n            } catch (_) {}\n          }\n          const wp = (e._path && e._path[e._pathIdx || 0]) || null;\n          if (wp) {\n            const tx = wp[0], ty = wp[1];\n            const pdx = tx - e.x; const pdy = ty - e.y;\n            const pd = Math.hypot(pdx, pdy) || 1;\n            if (pd < 10) { e._pathIdx = (e._pathIdx || 0) + 1; }\n            else { const px = pdx / pd; const py = pdy / pd; vx = px * speed; vy = py * speed; usingPath = true; }\n          }\n        }\n        // Snitch custom kiting movement\n        if (e.isSnitch) {\n          const desired = 280; const minD = 200; const maxD = 360;\n          // Choose a retreat target when too close, or orbit when in band\n          if (dist < minD) {\n            // Find a point away from player within arena\n            const backX = Phaser.Math.Clamp(e.x - nx * 180, 16, this.scale.width - 16);\n            const backY = Phaser.Math.Clamp(e.y - ny * 180, 16, this.scale.height - 16);\n            let tx = backX, ty = backY;\n            // Use pathfinding if LOS blocked\n            if (this._nav?.grid) {\n              try {\n                const [sgx, sgy] = worldToGrid(this._nav.grid, e.x, e.y);\n                const [ggx, ggy] = worldToGrid(this._nav.grid, tx, ty);\n                const path = findPath(this._nav.grid, sgx, sgy, ggx, ggy) || null;\n                if (path && path.length) {\n                  const wp = path[0];\n                  const pdx = wp[0] - e.x; const pdy = wp[1] - e.y;\n                  const pd = Math.hypot(pdx, pdy) || 1;\n                  const px = pdx / pd; const py = pdy / pd;\n                  vx = px * speed; vy = py * speed; usingPath = true;\n                }\n              } catch (_) {}\n            }\n            if (!usingPath) { vx = -nx * speed; vy = -ny * speed; }\n          } else if (dist > maxD) {\n            // Approach back into desired band\n            vx = nx * speed * 0.8; vy = ny * speed * 0.8;\n          } else {\n            // Strafe/orbit around player\n            const px = -ny, py = nx;\n            const dir = (e._strafeDir === -1) ? -1 : 1; e._strafeDir = dir;\n            vx = px * speed * 0.7 * dir; vy = py * speed * 0.7 * dir;\n            if (!e._nextStrafeFlip || now - e._nextStrafeFlip > 1600) { e._strafeDir = (Math.random() < 0.5) ? -1 : 1; e._nextStrafeFlip = now + Phaser.Math.Between(1600, 2600); }\n          }\n        }\n        // Treat snipers like shooters for movement behavior (exclude Snitch's custom logic)\n        if (!usingPath && ((e.isShooter && !e.isSnitch) || e.isSniper)) {\n          // Random wander; approach if far, back off if too close\n          if (!e._wanderChangeAt || now >= e._wanderChangeAt) {\n            // Longer hold times to avoid twitching\n            e._wanderChangeAt = now + Phaser.Math.Between(1400, 2600);\n            const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);\n            const mag = Phaser.Math.FloatBetween(0.6, 1.0);\n            e._wanderVX = Math.cos(ang) * speed * mag;\n            e._wanderVY = Math.sin(ang) * speed * mag;\n          }\n          // Desired velocity combines wander and a gentle bias toward/away from player\n          vx = (e._wanderVX || 0);\n          vy = (e._wanderVY || 0);\n          // Bias towards player direction even when not far\n          vx += nx * speed * 0.2; vy += ny * speed * 0.2;\n          const far = dist > 280, tooClose = dist < 140;\n          if (far) { vx += nx * speed * 0.75; vy += ny * speed * 0.75; }\n          else if (tooClose) { vx -= nx * speed * 0.65; vy -= ny * speed * 0.65; }\n        } else if (!usingPath) {\n          // Melee: zig-zag sometimes; otherwise straight chase, with occasional wander/flee\n          if (!e._zigPhase) e._zigPhase = Phaser.Math.FloatBetween(0, Math.PI * 2);\n          if (!e._mode || now >= (e._modeUntil || 0)) {\n            const r = Math.random();\n            if (r < 0.55) e._mode = 'straight';\n            else if (r < 0.75) e._mode = 'zig';\n            else if (r < 0.90) e._mode = 'wander';\n            else e._mode = 'flee';\n            e._modeUntil = now + Phaser.Math.Between(900, 2200);\n            if (e._mode === 'wander') {\n              const a = Phaser.Math.FloatBetween(0, Math.PI * 2);\n              e._wanderVX = Math.cos(a) * speed * 0.6;\n              e._wanderVY = Math.sin(a) * speed * 0.6;\n            }\n            if (e._mode === 'zig') {\n              // Choose a smooth frequency and strafe amplitude for this zig session\n              e._zigFreq = Phaser.Math.FloatBetween(1.0, 2.0); // Hz\n              e._zigAmp = Phaser.Math.FloatBetween(0.5, 0.75); // strafe weight (slightly reduced)\n            }\n          }\n          if (e._mode === 'zig') {\n            // Perpendicular wiggle to dodge\n            const px = -ny, py = nx;\n            if (!e._lastZigT) e._lastZigT = now;\n            const dtMs = Math.max(1, now - e._lastZigT);\n            // Smooth continuous phase advance based on frequency\n            const freq = e._zigFreq || 1.5; // Hz\n            e._zigPhase += (Math.PI * 2) * freq * (dtMs / 1000);\n            e._lastZigT = now;\n            const w = Math.sin(e._zigPhase);\n            const zigSpeed = speed * 1.5; // 150% of normal during zig-zag\n            const amp = e._zigAmp || 0.75;\n            vx = nx * zigSpeed * (0.85 + 0.10 * Math.sin(e._zigPhase * 0.5)) + px * zigSpeed * amp * w;\n            vy = ny * zigSpeed * (0.85 + 0.10 * Math.sin(e._zigPhase * 0.5)) + py * zigSpeed * amp * w;\n          } else if (e._mode === 'wander') {\n            vx = (e._wanderVX || 0) * 0.9; vy = (e._wanderVY || 0) * 0.9;\n          } else if (e._mode === 'straight') {\n            vx = nx * speed; vy = ny * speed;\n          } else { // flee\n            vx = -nx * speed * 0.9; vy = -ny * speed * 0.9;\n          }\n        }\n        // If disoriented by toxin, override with wander velocity but still allow firing logic later\n        if (!e.isBoss && e._toxinedUntil && now < e._toxinedUntil) {\n          vx = (e._wanderVX || 0);\n          vy = (e._wanderVY || 0);\n        }\n        // Grenadier enrage: charge player under 25% HP and explode on contact\n        if (e.isGrenadier && !e._charging && (typeof e.hp === 'number') && (typeof e.maxHp === 'number') && e.hp <= 0.25 * e.maxHp) {\n          e._charging = true;\n        }\n        if (e.isGrenadier && e._charging) {\n          // Prefer pathing around obstacles while charging if a path exists\n          const chargeMul = 4.0; // faster suicide run\n          if (!usingPath) {\n            const ang = Math.atan2(dy, dx);\n            const sp = (e.speed || 40) * chargeMul;\n            vx = Math.cos(ang) * sp; vy = Math.sin(ang) * sp;\n          } else {\n            // Scale the path-follow velocity up to match charge speed\n            vx *= chargeMul; vy *= chargeMul;\n          }\n        }\n        // Smooth velocity to avoid twitching (inertia/acceleration)\n        const smooth = 0.12; // approaching target ~12% per frame\n        if (e._svx === undefined) e._svx = 0;\n        if (e._svy === undefined) e._svy = 0;\n        e._svx += (vx - e._svx) * smooth;\n        e._svy += (vy - e._svy) * smooth;\n        // Post-sweep slow for melee enemies (reduced slowdown: 60% speed)\n        if (e.isMelee && e._meleeSlowUntil && now < e._meleeSlowUntil) { e._svx *= 0.6; e._svy *= 0.6; }\n        e.body.setVelocity(e._svx, e._svy);\n        // Stuck detection triggers repath (more aggressive during Grenadier charge)\n        if (e._lastPosT === undefined) { e._lastPosT = now; e._lx = e.x; e._ly = e.y; }\n        if (now - e._lastPosT > 400) {\n          const md = Math.hypot((e.x - (e._lx || e.x)), (e.y - (e._ly || e.y)));\n          e._lx = e.x; e._ly = e.y; e._lastPosT = now;\n          const stuckWhileCharging = (e.isGrenadier && e._charging && md < 3); if ((md < 2 && this.isLineBlocked(e.x, e.y, this.player.x, this.player.y)) || stuckWhileCharging) { e._path = null; e._pathIdx = 0; e._lastPathAt = 0; }\n        }\n      }\n      // Grenadier: detonate if player within trigger radius while charging\n      if (e.isGrenadier && e._charging) {\n        const dxp = this.player.x - e.x; const dyp = this.player.y - e.y;\n        const trig = (e.detonateTriggerRadius || 40);\n        if ((dxp * dxp + dyp * dyp) <= (trig * trig)) {\n          try { this.killEnemy(e); } catch (_) {}\n        }\n      }\n      // Clamp enemies to screen bounds as a failsafe\n      try {\n        const pad = (e.body?.halfWidth || 6);\n        const w = this.scale.width, h = this.scale.height;\n        e.x = Phaser.Math.Clamp(e.x, pad, w - pad);\n        e.y = Phaser.Math.Clamp(e.y, pad, h - pad);\n      } catch (_) {}\n\n      if (e.isShooter) {\n        if (!e.lastShotAt) e.lastShotAt = 0;\n        if (e.isPrism) {\n          const nowT = this.time.now;\n          // Prism: two behaviors 闁?sweeping beam, and special aim-then-beam\n          // Freeze during aim/beam\n          if (e._prismState === 'aim' || e._prismState === 'beam') {\n            try { e.body?.setVelocity?.(0, 0); } catch (_) {}\n            // Ensure sweep is cancelled while aiming or beaming\n            if (e._sweepActive) { e._sweepActive = false; try { e._laserG?.clear(); } catch (_) {} }\n          }\n          // End aim -> start beam\n          if (e._prismState === 'aim' && nowT >= (e._aimUntil || 0)) {\n            e._prismState = 'beam';\n            e._beamUntil = nowT + 1500; // 1.5s\n            // Lock beam angle at start toward player\n            e._beamAngle = Math.atan2((this.player.y - e.y), (this.player.x - e.x));\n            try { e._aimG?.clear(); } catch (_) {}\n            if (!e._laserG) { e._laserG = this.add.graphics(); try { e._laserG.setDepth(8000); e._laserG.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {} }\n            e._beamTickAccum = 0;\n          }\n          // Finish beam\n          if (e._prismState === 'beam' && nowT >= (e._beamUntil || 0)) {\n            e._prismState = 'idle';\n            try { e._laserG?.clear(); } catch (_) {}\n            // Reset sweep counter and delay next sweep so resuming isn't immediate\n            e._sweepsSinceAbility = 0;\n            e._nextSweepAt = nowT + Phaser.Math.Between(2500, 3500);\n          }\n          // Trigger special ability after 3 completed sweeps (not time-based)\n          if (e._prismState !== 'aim' && e._prismState !== 'beam') {\n            if ((e._sweepsSinceAbility || 0) >= 3 && !e._sweepActive) {\n              // Cancel any ongoing sweep when starting aim\n              if (e._sweepActive) { e._sweepActive = false; try { e._laserG?.clear(); } catch (_) {} }\n              e._sweepsSinceAbility = 0;\n              e._prismState = 'aim';\n              e._aimUntil = nowT + 800; // lock for 0.8s\n              if (!e._aimG) e._aimG = this.add.graphics();\n              try { e._aimG.clear(); } catch (_) {}\n              e._aimG.lineStyle(1, 0xff2222, 1);\n              e._aimG.beginPath(); e._aimG.moveTo(e.x, e.y); e._aimG.lineTo(this.player.x, this.player.y); e._aimG.strokePath();\n            }\n          }\n          // Update aim line\n          if (e._prismState === 'aim') {\n            if (e._aimG) {\n              try { e._aimG.clear(); e._aimG.lineStyle(1, 0xff2222, 1); e._aimG.beginPath(); e._aimG.moveTo(e.x, e.y); e._aimG.lineTo(this.player.x, this.player.y); e._aimG.strokePath(); } catch (_) {}\n            }\n          }\n          // Draw and apply beam damage (beam follows player during fire)\n          if (e._prismState === 'beam') {\n            // Continuously track player while firing\n            e._beamAngle = Math.atan2((this.player.y - e.y), (this.player.x - e.x));\n            this.renderPrismBeam(e, e._beamAngle, (this.game?.loop?.delta || 16.7)/1000, { applyDamage: true, damagePlayer: true, dps: 50, tick: 0.05 });\n          }\n          // Sweeping laser while idle\n          if (e._prismState === 'idle' || !e._prismState) {\n            if (!e._sweepActive && nowT >= (e._nextSweepAt || 0)) {\n              e._sweepActive = true;\n              const base = Math.atan2(this.player.y - e.y, this.player.x - e.x);\n              // Narrower sweep: 80 degrees total, slower\n              e._sweepFrom = base - Phaser.Math.DegToRad(40);\n              e._sweepTo = base + Phaser.Math.DegToRad(40);\n              e._sweepT = 0; e._sweepDuration = 1500; // ms\n              // Alternate sweep direction each time: 1 then -1 then 1 ...\n              e._sweepDir = (e._sweepDir === -1) ? 1 : -1;\n              if (!e._laserG) { e._laserG = this.add.graphics(); try { e._laserG.setDepth(8000); e._laserG.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {} }\n              e._sweepTickAccum = 0;\n            }\n            if (e._sweepActive) {\n              const dtMs = (this.game?.loop?.delta || 16.7);\n              e._sweepT += dtMs;\n              const t = Phaser.Math.Clamp(e._sweepT / (e._sweepDuration || 900), 0, 1);\n              const tt = (e._sweepDir === -1) ? (1 - t) : t;\n              const ang = e._sweepFrom + (e._sweepTo - e._sweepFrom) * tt;\n              // Sweeping beam now damages player; reduce DPS by 50%\n              this.renderPrismBeam(e, ang, dtMs / 1000, { applyDamage: true, damagePlayer: true, dps: 50 * 27 * 0.5 });\n              if (t >= 1) {\n                e._sweepActive = false; try { e._laserG?.clear(); } catch (_) {}\n                // Count completed sweep and schedule next unless ability will fire immediately\n                e._sweepsSinceAbility = (e._sweepsSinceAbility || 0) + 1;\n                if (e._sweepsSinceAbility >= 3) {\n                  // Start aim immediately after third sweep\n                  e._prismState = 'aim';\n                  e._aimUntil = nowT + 800;\n                  if (!e._aimG) e._aimG = this.add.graphics();\n                  try { e._aimG.clear(); e._aimG.lineStyle(1, 0xff2222, 1); e._aimG.beginPath(); e._aimG.moveTo(e.x, e.y); e._aimG.lineTo(this.player.x, this.player.y); e._aimG.strokePath(); } catch (_) {}\n                } else {\n                  e._nextSweepAt = nowT + Phaser.Math.Between(1200, 1800);\n                }\n              }\n            }\n          }\n        } else if (e.isSnitch) {\n          const nowT = this.time.now;\n          // Ability: call reinforcements every 8s\n          if (nowT >= (e._callNextAt || 0)) {\n            e._callNextAt = nowT + 8000;\n            // Spawn 1 reinforcement near the Snitch\n            const mods = (this.gs?.getDifficultyMods?.() || { enemyHp: 1, enemyDamage: 1 });\n            for (let k = 0; k < 1; k += 1) {\n              const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);\n              const r = Phaser.Math.Between(60, 120);\n              const sx = Phaser.Math.Clamp(e.x + Math.cos(ang) * r, 16, this.scale.width - 16);\n              const sy = Phaser.Math.Clamp(e.y + Math.sin(ang) * r, 16, this.scale.height - 16);\n              const roll = Math.random();\n              let spawnFn;\n              if (roll < 0.15) spawnFn = (sc, x, y) => createSniperEnemy(sc, x, y, Math.floor(80 * mods.enemyHp), Math.floor(18 * mods.enemyDamage), 40);\n              else if (roll < 0.35) spawnFn = (sc, x, y) => createShooterEnemy(sc, x, y, Math.floor(90 * mods.enemyHp), Math.floor(8 * mods.enemyDamage), 50, 900);\n              else if (roll < 0.50) spawnFn = (sc, x, y) => createMachineGunnerEnemy(sc, x, y, Math.floor(140 * mods.enemyHp), Math.floor(7 * mods.enemyDamage), 35, 1100, 12, 24);\n              else if (roll < 0.65) spawnFn = (sc, x, y) => createRocketeerEnemy(sc, x, y, Math.floor(80 * mods.enemyHp), Math.floor(12 * mods.enemyDamage), 40, 2000);\n              else if (roll < 0.85) spawnFn = (sc, x, y) => { const meleeDmg = Math.floor(Math.floor(10 * mods.enemyDamage) * 1.5); return createRunnerEnemy(sc, x, y, Math.floor(60 * mods.enemyHp), meleeDmg, 120); };\n              else spawnFn = (sc, x, y) => { const meleeDmg = Math.floor(Math.floor(10 * mods.enemyDamage) * 1.5); return createEnemy(sc, x, y, Math.floor(100 * mods.enemyHp), meleeDmg, 60); };\n              try { const ally = spawnFn(this, sx, sy); if (ally) this.enemies.add(ally); } catch (_) {}\n              // Teleport VFX for reinforcement spawn\n              try { bitSpawnRing(this, sx, sy, { radius: 22, lineWidth: 3, duration: 420, scaleTarget: 2.1, color: 0xaa66ff }); } catch (_) {}\n              try { impactBurst(this, sx, sy, { color: 0xaa66ff, size: 'small' }); } catch (_) {}\n            }\n          }\n          // Shotgun: only when close\n          const close = dist < 220;\n          const canShoot = close && (nowT - e.lastShotAt > 1000);\n          if (canShoot) {\n            e.lastShotAt = nowT;\n            const pellets = 3; const spreadDeg = 24;\n            const base = Math.atan2(dy, dx);\n            for (let pi = 0; pi < pellets; pi += 1) {\n              const t = (pellets === 1) ? 0 : (pi / (pellets - 1) - 0.5);\n              const ang = base + Phaser.Math.DegToRad(spreadDeg) * t;\n              const speedB = 260;\n              const vx = Math.cos(ang) * speedB; const vy = Math.sin(ang) * speedB;\n              const b = this.enemyBullets.get(e.x, e.y, 'bullet');\n              if (b) {\n                b.setActive(true).setVisible(true);\n                b.setCircle(2).setOffset(-2, -2);\n                b.setVelocity(vx, vy);\n                b.setTint(0xffcc00);\n                b.damage = e.damage;\n                b.update = () => { const view = this.cameras?.main?.worldView; if (view && !view.contains(b.x, b.y)) { b.destroy(); } };\n              }\n            }\n          }\n        } else if (e.isGrenadier) {\n          const nowT = this.time.now;\n          // On grenade mode unless charging; throw 3-grenade burst every 2s\n          if (!e._charging) {\n            if (!e._castingGrenades && nowT >= (e._grenadeNextAt || 0)) {\n              e._castingGrenades = true;\n              for (let i = 0; i < 3; i += 1) {\n                this.time.delayedCall(i * 300, () => {\n                  if (!e.active) return;\n                  const tx = this.player.x; const ty = this.player.y;\n                  this.throwEnemyGrenade(e, tx, ty);\n                  if (i === 2) { e._castingGrenades = false; }\n                });\n              }\n              e._grenadeNextAt = nowT + (e.burstCooldownMs || 2000);\n            }\n          }\n        } else if (e.isMachineGunner) {\n          const nowT = this.time.now;\n          // Start a new burst if cooled down and not currently bursting\n          if ((!e._burstLeft || e._burstLeft <= 0) && (nowT - e.lastShotAt > (e.fireRateMs || 1100))) {\n            e._burstLeft = e.burstCount || 15;\n            e._nextBurstShotAt = nowT;\n            e._sprayPhase = 0;\n          }\n          // Fire next bullet in the burst if it's time\n          if (e._burstLeft && e._burstLeft > 0 && nowT >= (e._nextBurstShotAt || 0)) {\n            const base = Math.atan2(dy, dx);\n            const spreadRad = Phaser.Math.DegToRad(e.spreadDeg || 14);\n            // Slight walk within spread over the burst\n            const t = ((e.burstCount || 15) - e._burstLeft) / Math.max(1, (e.burstCount || 15) - 1);\n            let ang = base + (t - 0.5) * spreadRad * 0.9;\n            if (e._toxinedUntil && now < e._toxinedUntil) {\n              const extra = Phaser.Math.DegToRad(50);\n              ang += Phaser.Math.FloatBetween(-extra/2, extra/2);\n            }\n            ang += Phaser.Math.FloatBetween(-0.05, 0.05) * spreadRad;\n            const speed = 250;\n            const vx = Math.cos(ang) * speed;\n            const vy = Math.sin(ang) * speed;\n            const b = this.enemyBullets.get(e.x, e.y, 'bullet');\n            if (b) {\n              b.setActive(true).setVisible(true);\n              b.setCircle(2).setOffset(-2, -2);\n              b.setVelocity(vx, vy);\n              b.setTint(0xffcc00);\n              b.damage = e.damage;\n              b.update = () => {\n                const view = this.cameras?.main?.worldView;\n                if (view && !view.contains(b.x, b.y)) { b.destroy(); }\n              };\n            }\n            e._burstLeft -= 1;\n            if (e._burstLeft <= 0) {\n              e.lastShotAt = nowT; // end of burst\n            } else {\n              e._nextBurstShotAt = nowT + (e.burstGapMs || 70);\n            }\n          }\n        } else if (e.isRocketeer) {\n          const nowT = this.time.now;\n          if (nowT - e.lastShotAt > (e.fireRateMs || 2000)) {\n            e.lastShotAt = nowT;\n            let ang = Math.atan2(dy, dx);\n            if (e._toxinedUntil && nowT < e._toxinedUntil) {\n              const extra = Phaser.Math.DegToRad(50);\n              ang += Phaser.Math.FloatBetween(-extra/2, extra/2);\n            }\n            const speed = 300;\n            const vx = Math.cos(ang) * speed;\n            const vy = Math.sin(ang) * speed;\n            const b = this.enemyBullets.get(e.x, e.y, 'bullet');\n            if (b) {\n              b.setActive(true).setVisible(true);\n              b.setCircle(6).setOffset(-6, -6);\n              try { b.setScale(1.4); } catch (_) {}\n              b.setVelocity(vx, vy);\n              b.setTint(0xff8844);\n              b.damage = e.damage;\n              b._rocket = true;\n              b._blastRadius = 70;\n              b.update = () => {\n                const view = this.cameras?.main?.worldView;\n                if (view && !view.contains(b.x, b.y)) { b.destroy(); }\n              };\n            }\n          }\n        } else {\n          const nowT = this.time.now;\n          // Shooter: 2-round burst (one at a time)\n          if ((!e._burstLeft || e._burstLeft <= 0) && (nowT - e.lastShotAt > (e.fireRateMs || 900))) {\n            e._burstLeft = 2;\n            e._nextBurstShotAt = nowT;\n            e._burstGapMsS = e._burstGapMsS || 110; // per-shot gap within burst\n          }\n          if (e._burstLeft && e._burstLeft > 0 && nowT >= (e._nextBurstShotAt || 0)) {\n            let ang = Math.atan2(dy, dx);\n            if (e._toxinedUntil && nowT < e._toxinedUntil) {\n              const extra = Phaser.Math.DegToRad(50);\n              ang += Phaser.Math.FloatBetween(-extra/2, extra/2);\n            }\n            const vx = Math.cos(ang) * 240;\n            const vy = Math.sin(ang) * 240;\n            const b = this.enemyBullets.get(e.x, e.y, 'bullet');\n            if (b) {\n              b.setActive(true).setVisible(true);\n              b.setCircle(2).setOffset(-2, -2);\n              b.setVelocity(vx, vy);\n              b.setTint(0xffff00); // enemy bullets are yellow\n              b.damage = e.damage;\n              b.update = () => {\n                const view = this.cameras?.main?.worldView;\n                if (view && !view.contains(b.x, b.y)) { b.destroy(); }\n              };\n            }\n            e._burstLeft -= 1;\n            if (e._burstLeft <= 0) {\n              e.lastShotAt = nowT; // burst complete\n            } else {\n              e._nextBurstShotAt = nowT + (e._burstGapMsS || 110);\n            }\n          }\n        }\n      }\n\n      // Sniper behavior\n      if (e.isSniper) {\n        const now = this.time.now;\n        // If aiming, freeze movement and draw/update red aim line\n        if (e.aiming) {\n          e.body.setVelocity(0, 0);\n          if (!e._aimG) e._aimG = this.add.graphics();\n          try {\n            e._aimG.clear();\n            e._aimG.lineStyle(1, 0xff2222, 1); // thinner sniper aim line\n            e._aimG.beginPath();\n            e._aimG.moveTo(e.x, e.y);\n            e._aimG.lineTo(this.player.x, this.player.y);\n            e._aimG.strokePath();\n          } catch (_) {}\n          if (now - (e.aimStartedAt || 0) >= (e.aimDurationMs || 1000)) {\n            // Fire a slower, high-damage shot\n            let angle = Math.atan2(dy, dx);\n            if (e._toxinedUntil && now < e._toxinedUntil) {\n              const extra = Phaser.Math.DegToRad(50);\n              angle += Phaser.Math.FloatBetween(-extra/2, extra/2);\n            }\n            const snipeSpeed = 1200;\n            const vx = Math.cos(angle) * snipeSpeed;\n            const vy = Math.sin(angle) * snipeSpeed;\n            const b = this.enemyBullets.get(e.x, e.y, 'bullet');\n            if (b) {\n              b.setActive(true).setVisible(true);\n              // Slightly larger hitbox to avoid tunneling at extreme speed\n              b.setCircle(3).setOffset(-3, -3);\n              b.setVelocity(vx, vy);\n              b.damage = Math.max(35, Math.floor((e.damage || 20) * 2.0)); // higher sniper damage\n              b.setTint(0xff3333);\n              b._sniper = true;\n              b._px = b.x; b._py = b.y;\n              b.update = () => {\n                // Manual ray-style collision to prevent tunneling at extreme speed\n                try {\n                  const line = new Phaser.Geom.Line(b._px || b.x, b._py || b.y, b.x, b.y);\n                  const playerRect = this.player.getBounds();\n                  if (Phaser.Geom.Intersects.LineToRectangle(line, playerRect)) {\n                    const inIframes = this.time.now < this.player.iframesUntil;\n                    if (!inIframes) {\n                      const dmg = (typeof b.damage === 'number' && b.damage > 0) ? b.damage : 8;\n                      this.applyPlayerDamage(dmg);\n                      this.player.iframesUntil = this.time.now + 600;\n                      if (this.gs.hp <= 0) {\n                        const eff = getPlayerEffects(this.gs);\n                        this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n                        this.gs.nextScene = SceneKeys.Hub;\n                        SaveManager.saveToLocal(this.gs);\n                        this.scene.start(SceneKeys.Hub);\n                      }\n                    }\n                    try { b.destroy(); } catch (_) {}\n                    return;\n                  }\n                } catch (_) {}\n                // Lifetime via camera view when walls are disabled\n                const view = this.cameras?.main?.worldView;\n                if (view && !view.contains(b.x, b.y)) { b.destroy(); return; }\n                // Update previous position for next frame\n                b._px = b.x; b._py = b.y;\n              };\n            }\n            // End aiming and start cooldown; remove laser\n            e.aiming = false;\n            e.lastShotAt = now;\n            try { e._aimG?.clear(); e._aimG?.destroy(); e._aimG = null; } catch (_) {}\n          }\n        } else {\n          // Not aiming: use normal movement like other shooters; only manage aim trigger\n          // Start aiming if cooldown passed\n          if (!e.lastShotAt) e.lastShotAt = 0;\n          if (now - e.lastShotAt >= (e.cooldownMs || 2000)) {\n            e.aiming = true;\n            e.aimStartedAt = now;\n          }\n        }\n      }\n    });\n\n    // Check clear (count only enemies that are active AND have HP left)\n    const alive = this.enemies.getChildren().filter((e) => e.active && (typeof e.hp === 'number' ? e.hp > 0 : true)).length;\n    if (alive === 0 && !this.exitActive) {\n      this.exitActive = true;\n      this.prompt.setText('Room clear! E to exit');\n      this.exitRect = new Phaser.Geom.Rectangle(this.scale.width - 50, this.scale.height / 2 - 30, 40, 60);\n      this.exitG.clear();\n      this.exitG.fillStyle(0x22ff88, 1).fillRect(this.exitRect.x, this.exitRect.y, this.exitRect.width, this.exitRect.height);\n    }\n\n    if (this.exitActive) {\n      const playerRect = this.player.getBounds();\n      if (Phaser.Geom.Intersects.RectangleToRectangle(playerRect, this.exitRect)) {\n        if (this.inputMgr.pressedInteract) {\n          this.gs.progressAfterCombat();\n          SaveManager.saveToLocal(this.gs);\n          const next = this.gs.nextScene === 'Boss' ? SceneKeys.Boss : SceneKeys.Combat;\n          this.scene.start(next);\n        }\n      }\n    }\n  }\n\n  createArenaWalls(room) {\n    const { width, height } = this.scale;\n    const tile = 16;\n    const w = Math.min(room.width * tile, width - 80);\n    const h = Math.min(room.height * tile, height - 80);\n    const x = (width - w) / 2;\n    const y = (height - h) / 2;\n    this.arenaRect = new Phaser.Geom.Rectangle(x, y, w, h);\n\n    // Visual wall tiles and physics\n    this.walls = this.physics.add.staticGroup();\n    const tilesX = Math.ceil(w / tile);\n    const tilesY = Math.ceil(h / tile);\n    // Top & Bottom rows\n    for (let i = 0; i < tilesX; i += 1) {\n      const wx = x + i * tile + tile / 2;\n      const top = this.physics.add.staticImage(wx, y + tile / 2, 'wall_tile');\n      const bot = this.physics.add.staticImage(wx, y + h - tile / 2, 'wall_tile');\n      this.walls.add(top); this.walls.add(bot);\n    }\n    // Left & Right cols\n    for (let j = 1; j < tilesY - 1; j += 1) {\n      const wy = y + j * tile + tile / 2;\n      const left = this.physics.add.staticImage(x + tile / 2, wy, 'wall_tile');\n      const right = this.physics.add.staticImage(x + w - tile / 2, wy, 'wall_tile');\n      this.walls.add(left); this.walls.add(right);\n    }\n  }\n\n  // Returns the effective magazine capacity for the currently active weapon\n  getActiveMagCapacity() {\n    try {\n      const w = getEffectiveWeapon(this.gs, this.gs.activeWeapon);\n      const useCeil = !!w._magRoundUp;\n      const raw = (w.magSize || 1);\n      const cap = Math.max(1, useCeil ? Math.ceil(raw) : Math.floor(raw));\n      return cap;\n    } catch (_) {\n      return 1;\n    }\n  }\n\n  // Enemy grenade helper (Grenadier)\n  throwEnemyGrenade(e, targetX, targetY) {\n    const b = this.enemyGrenades.get(e.x, e.y, 'bullet');\n    if (!b) return;\n    b.setActive(true).setVisible(true);\n    // Visual: slightly larger red projectile\n    b.setCircle(3).setOffset(-3, -3);\n    try { b.setScale(1.2); } catch (_) {}\n    b.setTint(0xff4444);\n    const angle = Math.atan2(targetY - e.y, targetX - e.x);\n    const speed = 280; // increased range and speed\n    const vx = Math.cos(angle) * speed; const vy = Math.sin(angle) * speed;\n    b.setVelocity(vx, vy);\n    b._spawnAt = this.time.now;\n    b._lifeMs = 1200; // longer flight lifetime for greater range\n    b._targetX = targetX; b._targetY = targetY;\n    b._grenade = true; b._grenadeRadius = 60; b.damage = (e?.damage || 14);\n    b.update = () => {\n      const now = this.time.now;\n      const dx = b.x - b._targetX; const dy = b.y - b._targetY;\n      const near = (dx * dx + dy * dy) <= 18 * 18;\n      const expired = (now - (b._spawnAt || 0)) >= (b._lifeMs || 800);\n      const view = this.cameras?.main?.worldView; const off = view && !view.contains(b.x, b.y);\n      if (near || expired || off) {\n        const ex = b.x; const ey = b.y; const radius = 60; // smaller radius vs boss\n        try { impactBurst(this, ex, ey, { color: 0xff3333, size: 'large', radius }); } catch (_) {}\n        // Player damage if within radius\n        const r2 = radius * radius; const pdx = this.player.x - ex; const pdy = this.player.y - ey;\n        if ((pdx * pdx + pdy * pdy) <= r2) {\n          if (now >= (this.player.iframesUntil || 0)) {\n            { let dmg=(e?.damage||14); try{ const eff=getPlayerEffects(this.gs)||{}; const mul=eff.enemyExplosionDmgMul||1; dmg=Math.ceil(dmg*mul);}catch(_){} this.applyPlayerDamage(dmg); }\n            this.player.iframesUntil = now + 600;\n            if (this.gs.hp <= 0) {\n              const eff = getPlayerEffects(this.gs);\n              this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n              this.gs.nextScene = SceneKeys.Hub;\n              SaveManager.saveToLocal(this.gs);\n              this.scene.start(SceneKeys.Hub);\n            }\n          }\n        }\n        // Also damage destructible barricades\n        this.damageSoftBarricadesInRadius(ex, ey, radius, (e.damage || 14));\n        try { b.destroy(); } catch (_) {}\n      }\n    };\n  }\n\n  // Prism beam renderer: draws thick laser and applies damage to player\n  renderPrismBeam(e, angle, dt, opts = {}) {\n    const applyDamage = opts.applyDamage !== undefined ? opts.applyDamage : true;\n    const damagePlayer = opts.damagePlayer !== undefined ? opts.damagePlayer : true;\n    const dps = (typeof opts.dps === 'number') ? opts.dps : 34;\n    const tick = (typeof opts.tick === 'number' && opts.tick > 0) ? opts.tick : dt; // default to per-frame\n    try { if (!e._laserG) { e._laserG = this.add.graphics(); e._laserG.setDepth(8000); e._laserG.setBlendMode(Phaser.BlendModes.ADD); } } catch (_) {}\n    const g = e._laserG;\n    try { g.clear(); } catch (_) {}\n    // Compute end vs barricades, then render thicker dual-color beam\n    const hit = this.computeEnemyLaserEnd(e.x, e.y, angle);\n    const ex = hit.ex, ey = hit.ey;\n    try {\n      g.lineStyle(5, 0xff3333, 0.95).beginPath(); g.moveTo(e.x, e.y); g.lineTo(ex, ey); g.strokePath();\n      g.lineStyle(2, 0x66aaff, 1).beginPath(); g.moveTo(e.x, e.y - 1); g.lineTo(ex, ey); g.strokePath();\n    } catch (_) {}\n    // Particles at endpoint\n    try { impactBurst(this, ex, ey, { color: 0xff4455, size: 'small' }); } catch (_) {}\n    // Damage ticking to player if intersecting beam\n    if (applyDamage) {\n      e._beamTickAccum = (e._beamTickAccum || 0) + dt;\n      while (e._beamTickAccum >= tick) {\n        e._beamTickAccum -= tick;\n        // Check if beam line hits player's bounds\n        const line = new Phaser.Geom.Line(e.x, e.y, ex, ey);\n        const rect = this.player.getBounds?.() || new Phaser.Geom.Rectangle(this.player.x - 6, this.player.y - 6, 12, 12);\n        if (damagePlayer && Phaser.Geom.Intersects.LineToRectangle(line, rect)) {\n          if (this.time.now >= (this.player.iframesUntil || 0)) {\n            const dmg = Math.max(1, Math.round(dps * tick));\n            this.applyPlayerDamage(dmg);\n            this.player.iframesUntil = this.time.now + 250; // brief i-frames vs continuous laser\n            if (this.gs.hp <= 0) {\n              const eff = getPlayerEffects(this.gs);\n              this.gs.hp = (this.gs.maxHp || 0) + (eff.bonusHp || 0);\n              this.gs.nextScene = SceneKeys.Hub;\n              SaveManager.saveToLocal(this.gs);\n              this.scene.start(SceneKeys.Hub);\n            }\n          }\n        }\n        // Damage soft barricades intersecting the beam\n        try {\n          const arr = this.barricadesSoft?.getChildren?.() || [];\n          for (let i = 0; i < arr.length; i += 1) {\n            const s = arr[i]; if (!s?.active) continue;\n            if (!s.getData('destructible')) continue;\n            const sRect = s.getBounds?.() || new Phaser.Geom.Rectangle(s.x - 8, s.y - 8, 16, 16);\n            if (Phaser.Geom.Intersects.LineToRectangle(line, sRect)) {\n              const hp0 = (typeof s.getData('hp') === 'number') ? s.getData('hp') : 20;\n              const dmg = Math.max(1, Math.round(dps * tick));\n              const hp1 = hp0 - dmg;\n              if (hp1 <= 0) { try { s.destroy(); } catch (_) {} }\n              else s.setData('hp', hp1);\n            }\n          }\n        } catch (_) {}\n      }\n    }\n  }\n\n  // Compute enemy laser line clipped to barricades\n  computeEnemyLaserEnd(sx, sy, angle) {\n    const maxLen = 1000;\n    const ex0 = sx + Math.cos(angle) * maxLen;\n    const ey0 = sy + Math.sin(angle) * maxLen;\n    const ray = new Phaser.Geom.Line(sx, sy, ex0, ey0);\n    let ex = ex0; let ey = ey0; let bestD2 = Infinity;\n    const testGroups = [this.barricadesHard, this.barricadesSoft];\n    for (let gi = 0; gi < testGroups.length; gi += 1) {\n      const g = testGroups[gi]; if (!g) continue;\n      const arr = g.getChildren?.() || [];\n      for (let i = 0; i < arr.length; i += 1) {\n        const s = arr[i]; if (!s?.active) continue;\n        const rect = s.getBounds?.() || new Phaser.Geom.Rectangle(s.x - 8, s.y - 8, 16, 16);\n        const pts = Phaser.Geom.Intersects.GetLineToRectangle(ray, rect);\n        if (pts && pts.length) {\n          const p = pts[0]; const dx = p.x - sx; const dy = p.y - sy; const d2 = dx * dx + dy * dy;\n          if (d2 < bestD2) { bestD2 = d2; ex = p.x; ey = p.y; }\n        }\n      }\n    }\n    return { ex, ey };\n  }\n\n  // Ensure ammo entry exists for weaponId. If clampOnly, only caps ammo when above capacity\n  ensureAmmoFor(weaponId, capacity, clampOnly = false) {\n    if (weaponId == null) return;\n    if (this.ammoByWeapon[weaponId] == null) {\n      this.ammoByWeapon[weaponId] = Math.max(0, capacity | 0);\n      return;\n    }\n    if (clampOnly) {\n      if (this.ammoByWeapon[weaponId] > capacity) this.ammoByWeapon[weaponId] = capacity;\n    }\n  }\n\n  // Returns reload time in ms for active weapon (default 1.5s, rocket 2s)\n  getActiveReloadMs() {\n    try {\n      const w = getEffectiveWeapon(this.gs, this.gs.activeWeapon);\n      if (typeof w.reloadMs === 'number') return w.reloadMs;\n      return (w.projectile === 'rocket') ? 1000 : 1500;\n    } catch (_) {\n      return 1500;\n    }\n  }\n\n  deployADS() {\n    const x = this.player.x; const y = this.player.y;\n    // Use asset sprite for ADS and fit to small height\n    const g = createFittedImage(this, x, y, 'ability_ads',  20);\n    try { g.setDepth(9000); } catch (_) {}\n    const obj = { x, y, g, radius: 120, nextZapAt: 0, until: this.time.now + 8000 };\n    this._gadgets.push(obj);\n  }\n\n  deployRepulsionPulse() {\n    if (!this._repulses) this._repulses = [];\n    const x = this.player.x; const y = this.player.y;\n    const g = this.add.graphics({ x, y });\n    try { g.setDepth?.(9000); } catch (_) {}\n    try { g.setBlendMode?.(Phaser.BlendModes.ADD); } catch (_) {}\n    const rect = this.arenaRect || new Phaser.Geom.Rectangle(0, 0, this.scale.width, this.scale.height);\n    const corners = [\n      { x: rect.left, y: rect.top },\n      { x: rect.right, y: rect.top },\n      { x: rect.right, y: rect.bottom },\n      { x: rect.left, y: rect.bottom },\n    ];\n    let maxD = 0; for (let i = 0; i < corners.length; i += 1) { const dx = corners[i].x - x; const dy = corners[i].y - y; const d = Math.hypot(dx, dy); if (d > maxD) maxD = d; }\n    const obj = { x, y, r: 0, band: 8, speed: 300, maxR: maxD + 24, g };\n    this._repulses.push(obj);\n  }\n\n  deployBITs() {\n    if (!this._bits) this._bits = [];\n    // Green spawn ring for visual parity with Boss room\n    try { bitSpawnRing(this, this.player.x, this.player.y, { radius: 18, lineWidth: 3, duration: 420, scaleTarget: 2.0 }); } catch (_) {}\n    // Green pixel burst around player on release\n    try {\n      const cx = this.player.x, cy = this.player.y;\n      for (let i = 0; i < 18; i += 1) {\n        const a = Phaser.Math.FloatBetween(0, Math.PI * 2);\n        pixelSparks(this, cx, cy, { angleRad: a, count: 1, spreadDeg: 6, speedMin: 80, speedMax: 180, lifeMs: 240, color: 0x33ff66, size: 2, alpha: 0.8 });\n      }\n    } catch (_) {}\n    const count = 6;\n    for (let i = 0; i < count; i += 1) {\n      // Use asset sprite for BIT unit and fit to moderate height\n      const g = createFittedImage(this, this.player.x, this.player.y, 'ability_bit', 14);\n      try { g.setDepth(9000); } catch (_) {}\n      const bit = { x: this.player.x, y: this.player.y, vx: 0, vy: 0, g, target: null, lastShotAt: 0, holdUntil: 0, moveUntil: 0, despawnAt: this.time.now + 7000, spawnScatterUntil: this.time.now + Phaser.Math.Between(260, 420) };\n      // Thruster VFX (additive tiny tail like missiles)\n      try { bit._thr = this.add.graphics(); bit._thr.setDepth(8800); bit._thr.setBlendMode?.(Phaser.BlendModes.ADD); } catch (_) {}\n      // initial scatter velocity\n      const a = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const sp = Phaser.Math.Between(180, 260);\n      bit.vx = Math.cos(a) * sp; bit.vy = Math.sin(a) * sp; bit.moveUntil = this.time.now + Phaser.Math.Between(200, 400);\n      this._bits.push(bit);\n    }\n  }\n\n  // Railgun mechanics\n  handleRailgunCharge(now, weapon, ptr) {\n    const wid = this.gs.activeWeapon;\n    const cap = this.getActiveMagCapacity();\n    this.ensureAmmoFor(wid, cap);\n    const ammo = this.ammoByWeapon[wid] ?? 0;\n    // Cancel charge if swapping away handled elsewhere\n    if (this.reload.active || ammo <= 0) {\n      this.endRailAim();\n      return;\n    }\n    const maxMs = 1500;\n    if (!this.rail) this.rail = { charging: false, startedAt: 0, aimG: null };\n    const coreHold = !!weapon.railHold;\n    const baseAngle = Phaser.Math.Angle.Between(this.player.x, this.player.y, ptr.worldX, ptr.worldY);\n\n    if (ptr.isDown && ((ptr.buttons & 1) === 1)) {\n      if (!this.rail.charging) {\n        if (!this.lastShot || (now - this.lastShot) > weapon.fireRateMs) {\n          this.rail.charging = true;\n          this.rail.startedAt = now;\n          try {\n            const key = ensurePixelParticle(this, 'rail_px', 0x66aaff, 1) || 'rail_px';\n            this.rail._mgr = this.add.particles(key);\n            try { this.rail._mgr.setDepth(9500); } catch (_) {}\n            try { this.rail._mgr.setBlendMode?.(Phaser.BlendModes.ADD); } catch (_) {}\n            this.rail._em = this.rail._mgr.createEmitter({\n              speed: { min: 10, max: 60 },\n              lifespan: { min: 180, max: 320 },\n              alpha: { start: 1.0, end: 0 },\n              scale: 1,\n              gravityY: 0,\n              quantity: 0,\n            });\n          } catch (_) {}\n        }\n      }\n    } else {\n      // Released: fire if charging\n      if (this.rail.charging) {\n        const t = Math.min(1, (now - this.rail.startedAt) / maxMs);\n        this.fireRailgun(baseAngle, weapon, t);\n        this.rail.charging = false;\n        this.endRailAim();\n      }\n      return;\n    }\n\n    // While holding\n    if (this.rail.charging) {\n      const t = Math.min(1, (now - this.rail.startedAt) / maxMs);\n      this.drawRailAim(baseAngle, weapon, t);\n      if (t >= 1 && !coreHold) {\n        // Auto-fire at max unless core allows holding\n        this.fireRailgun(baseAngle, weapon, t);\n        this.rail.charging = false;\n        this.endRailAim();\n      }\n    }\n  }\n\n  drawRailAim(angle, weapon, t) {\n    try {\n      if (!this.rail?.aimG) this.rail.aimG = this.add.graphics();\n      const g = this.rail.aimG; g.clear(); g.setDepth(9000);\n      const spread0 = Phaser.Math.DegToRad(Math.max(0, weapon.spreadDeg || 0));\n      const spread = spread0 * (1 - t);\n      // Full-screen length: use screen diagonal with small margin\n      const diag = Math.hypot(this.scale.width, this.scale.height);\n      const len = Math.ceil(diag + 32);\n      // Thinner guide line\n      g.lineStyle(0.5, 0xffffff, 0.9);\n      const a1 = angle - spread / 2; const a2 = angle + spread / 2;\n      const x = this.player.x; const y = this.player.y;\n      g.beginPath(); g.moveTo(x, y); g.lineTo(x + Math.cos(a1) * len, y + Math.sin(a1) * len); g.strokePath();\n      g.beginPath(); g.moveTo(x, y); g.lineTo(x + Math.cos(a2) * len, y + Math.sin(a2) * len); g.strokePath();\n      // Blue pixel sparks from multiple points along barrel (very subtle while charging)\n      try {\n        const ts = [0.35, 0.55, 0.8];\n        const pick = Phaser.Math.Between(0, ts.length - 1);\n        const pt = getWeaponBarrelPoint(this, ts[pick], 3);\n        const common = { spreadDeg: 10, speedMin: 40, speedMax: 90, lifeMs: 140, color: 0x66aaff, size: 1, alpha: 0.45 };\n        pixelSparks(this, pt.x, pt.y, { angleRad: angle - Math.PI / 2, count: 1, ...common });\n        pixelSparks(this, pt.x, pt.y, { angleRad: angle + Math.PI / 2, count: 1, ...common });\n      } catch (_) {}\n    } catch (_) {}\n  }\n\n  endRailAim() {\n    try { this.rail?.aimG?.clear(); this.rail?.aimG?.destroy(); } catch (_) {}\n    try { this.rail?._mgr?.destroy(); } catch (_) {}\n    if (this.rail) { this.rail.aimG = null; this.rail._mgr = null; this.rail._em = null; }\n  }\n\n  fireRailgun(baseAngle, weapon, t) {\n    const wid = this.gs.activeWeapon;\n    const cap = this.getActiveMagCapacity();\n    this.ensureAmmoFor(wid, cap);\n    const ammo = this.ammoByWeapon[wid] ?? 0;\n    if (ammo <= 0 || this.reload.active) return;\n    const dmg = Math.floor(weapon.damage * (1 + 2 * t));\n    const speed = Math.floor(weapon.bulletSpeed * (1 + 2 * t));\n    const spreadRad = Phaser.Math.DegToRad(Math.max(0, (weapon.spreadDeg || 0))) * (1 - t);\n    const off = (spreadRad > 0) ? Phaser.Math.FloatBetween(-spreadRad / 2, spreadRad / 2) : 0;\n    const angle = baseAngle + off;\n    const vx = Math.cos(angle) * speed;\n    const vy = Math.sin(angle) * speed;\n    const b = this.bullets.get(this.player.x, this.player.y, 'bullet');\n    if (!b) return;\n    b.setActive(true).setVisible(true);\n    b.setCircle(2).setOffset(-2, -2);\n    b.setVelocity(vx, vy);\n    b.damage = dmg;\n    b.setTint(0x66aaff);\n    b._core = 'pierce';\n    b._pierceLeft = 999; // effectively unlimited pierce\n    b._rail = true; // identify railgun bullets for special handling\n    b._stunOnHit = weapon._stunOnHit || 0;\n    // Simple light-blue trail\n    const trail = this.add.graphics();\n    b._g = trail; trail.setDepth(8000);\n    b._px = b.x; b._py = b.y;\n    b.update = () => {\n      try {\n        // Draw trail\n        trail.clear();\n        trail.lineStyle(2, 0xaaddff, 0.9);\n        const tx = b.x - (vx * 0.02); const ty = b.y - (vy * 0.02);\n        trail.beginPath(); trail.moveTo(b.x, b.y); trail.lineTo(tx, ty); trail.strokePath();\n      } catch (_) {}\n\n      // Manual hit check to avoid tunneling at high speed\n      try {\n        const line = new Phaser.Geom.Line(b._px ?? b.x, b._py ?? b.y, b.x, b.y);\n        if (!b._hitSet) b._hitSet = new Set();\n        const arr = this.enemies?.getChildren?.() || [];\n        for (let i = 0; i < arr.length; i += 1) {\n          const e = arr[i];\n          if (!e || !e.active) continue;\n          if (b._hitSet.has(e)) continue;\n          const rect = e.getBounds();\n        if (Phaser.Geom.Intersects.LineToRectangle(line, rect)) {\n          if (e.isDummy) {\n            // Railgun dummy recording: accumulate but do not change HP\n            this._dummyDamage = (this._dummyDamage || 0) + (b.damage || 10);\n            if (b._stunOnHit && b._stunOnHit > 0) {\n              const nowS = this.time.now;\n              e._stunValue = Math.min(10, (e._stunValue || 0) + b._stunOnHit);\n              if ((e._stunValue || 0) >= 10) {\n                e._stunnedUntil = nowS + 200;\n                e._stunValue = 0;\n                if (!e._stunIndicator) { e._stunIndicator = this.add.graphics(); try { e._stunIndicator.setDepth(9000); } catch (_) {} e._stunIndicator.fillStyle(0xffff33, 1).fillCircle(0, 0, 2); }\n                try { e._stunIndicator.setPosition(e.x, e.y - 22); } catch (_) {}\n              }\n            }\n          } else {\n            if (typeof e.hp !== 'number') e.hp = e.maxHp || 20;\n            e.hp -= (b.damage || 10);\n            if (b._stunOnHit && b._stunOnHit > 0) {\n              const nowS = this.time.now;\n              e._stunValue = Math.min(10, (e._stunValue || 0) + b._stunOnHit);\n              if ((e._stunValue || 0) >= 10) {\n                e._stunnedUntil = nowS + 200;\n                e._stunValue = 0;\n                if (!e._stunIndicator) { e._stunIndicator = this.add.graphics(); try { e._stunIndicator.setDepth(9000); } catch (_) {} e._stunIndicator.fillStyle(0xffff33, 1).fillCircle(0, 0, 2); }\n                try { e._stunIndicator.setPosition(e.x, e.y - 22); } catch (_) {}\n              }\n            }\n          }\n            try { impactBurst(this, b.x, b.y, { color: 0xaaddff, size: 'small' }); } catch (_) {}\n            b._hitSet.add(e);\n            if (!e.isDummy && e.hp <= 0) { try { this.killEnemy ? this.killEnemy(e) : e.destroy(); } catch (_) {} }\n          }\n        }\n        // Railgun should pierce barricades and not damage them.\n        // For non-rail bullets, use normal barricade handling; for rail, trigger only a pierce VFX once per barricade.\n        if (!b._rail) {\n          const hitBarricade = (grp) => {\n            if (!grp) return false;\n            const arrS = grp.getChildren?.() || [];\n            for (let j = 0; j < arrS.length; j += 1) {\n              const s = arrS[j]; if (!s?.active) continue;\n              const r = s.getBounds();\n              if (Phaser.Geom.Intersects.LineToRectangle(line, r)) {\n                try { this.onBulletHitBarricade(b, s); } catch (_) { try { b.destroy(); } catch (__ ) {} }\n                return true;\n              }\n            }\n            return false;\n          };\n          if (hitBarricade(this.barricadesHard)) return;\n          if (hitBarricade(this.barricadesSoft)) return;\n        } else {\n          // Rail: spawn a small spark the first time we pass through each barricade\n          const pierceVfx = (grp) => {\n            if (!grp) return;\n            const arrS = grp.getChildren?.() || [];\n            if (!b._piercedBarricades) b._piercedBarricades = new Set();\n            for (let j = 0; j < arrS.length; j += 1) {\n              const s = arrS[j]; if (!s?.active) continue;\n              if (b._piercedBarricades.has(s)) continue;\n              const r = s.getBounds();\n              if (Phaser.Geom.Intersects.LineToRectangle(line, r)) {\n                b._piercedBarricades.add(s);\n                try { impactBurst(this, b.x, b.y, { color: 0xaaddff, size: 'small' }); } catch (_) {}\n              }\n            }\n          };\n          pierceVfx(this.barricadesHard);\n          pierceVfx(this.barricadesSoft);\n        }\n      } catch (_) {}\n\n      // Offscreen cleanup\n      const view = this.cameras?.main?.worldView;\n      if (view && !view.contains(b.x, b.y)) { try { b.destroy(); } catch (_) {} }\n      b._px = b.x; b._py = b.y;\n    };\n    b.on('destroy', () => { try { b._g?.destroy(); } catch (_) {} });\n    // Rail muzzle VFX: big blue split flash + particle burst\n    try {\n      const m = getWeaponMuzzleWorld(this, 3);\n      muzzleFlashSplit(this, m.x, m.y, { angle, color: 0xaaddff, count: 4, spreadDeg: 30, length: 24, thickness: 5 });\n      // Stronger pixel spark burst on fire\n      const burst = { spreadDeg: 14, speedMin: 160, speedMax: 280, lifeMs: 280, color: 0x66aaff, size: 2, alpha: 0.9 };\n      pixelSparks(this, m.x, m.y, { angleRad: angle - Math.PI / 2, count: 10, ...burst });\n      pixelSparks(this, m.x, m.y, { angleRad: angle + Math.PI / 2, count: 10, ...burst });\n      if (this.rail?._em) { try { this.rail._em.explode?.(60, m.x, m.y); } catch (_) {} }\n      try { this.rail?._mgr?.destroy(); } catch (_) {}\n      if (this.rail) { this.rail._mgr = null; this.rail._em = null; }\n    } catch (_) {}\n    // High recoil kick for railgun on fire\n    try { this._weaponRecoil = Math.max(this._weaponRecoil || 0, 5.5); } catch (_) {}\n    // consume ammo and start cooldown\n    this.ammoByWeapon[wid] = Math.max(0, (this.ammoByWeapon[wid] ?? cap) - 1);\n    this.registry.set('ammoInMag', this.ammoByWeapon[wid]);\n    this.lastShot = this.time.now;\n    if (this.ammoByWeapon[wid] <= 0) {\n      // trigger reload\n      if (!this.reload.active) {\n        this.reload.active = true;\n        this.reload.duration = this.getActiveReloadMs();\n        this.reload.until = this.time.now + this.reload.duration;\n        this.registry.set('reloadActive', true);\n        this.registry.set('reloadProgress', 0);\n      }\n    }\n  }\n\n  // Laser mechanics: continuous beam with heat/overheat and ignite buildup\n  handleLaser(now, weapon, ptr, dt) {\n    if (!this.laser) this.laser = { heat: 0, firing: false, overheat: false, startedAt: 0, coolDelayUntil: 0, g: null, lastTickAt: 0 };\n    // Initialize graphics once\n    if (!this.laser.g) {\n      this.laser.g = this.add.graphics();\n      try { this.laser.g.setDepth(8000); } catch (_) {}\n      try { this.laser.g.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n    }\n    if (!this.laser.mg) {\n      this.laser.mg = this.add.graphics();\n      try { this.laser.mg.setDepth(9000); } catch (_) {}\n      try { this.laser.mg.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n    }\n    const lz = this.laser;\n    const canPress = ptr?.isDown && ((ptr.buttons & 1) === 1);\n    const canFire = canPress && !lz.overheat;\n    const heatPerSec = 1 / 5; // overheat in 5s\n    const coolDelay = 0.5; // start cooling after 0.5s when not firing\n    const coolFastPerSec = 2.5; // fast cool\n    const tickRate = 0.1; // damage tick 10 Hz\n\n    // Update heat/overheat state\n    if (canFire) {\n      if (!lz.firing) { lz.firing = true; lz.startedAt = now; }\n      lz.heat = Math.min(1, lz.heat + heatPerSec * dt);\n      if (lz.heat >= 1 && !lz.overheat) {\n        // Force cooldown using reload bar\n        lz.overheat = true;\n        this.reload.active = true;\n        this.reload.duration = this.getActiveReloadMs();\n        this.reload.until = now + this.reload.duration;\n        this.registry.set('reloadActive', true);\n        this.registry.set('reloadProgress', 0);\n      }\n    } else {\n      if (lz.firing) { lz.firing = false; lz.coolDelayUntil = now + Math.floor(coolDelay * 1000); }\n      // cooling\n      if (!lz.overheat) {\n        if (now >= lz.coolDelayUntil) {\n          lz.heat = Math.max(0, lz.heat - coolFastPerSec * dt);\n        }\n      } else {\n        // During overheat, rely on reload to finish\n        if (!this.reload.active || now >= this.reload.until) {\n          // finish cooldown\n          lz.overheat = false;\n          lz.heat = 0;\n          this.reload.active = false;\n          this.reload.duration = 0;\n          this.registry.set('reloadActive', false);\n          this.registry.set('reloadProgress', 1);\n        } else {\n          // keep UI reload progress updated\n          const remaining = Math.max(0, this.reload.until - now);\n          const dur = Math.max(1, this.reload.duration || this.getActiveReloadMs());\n          const prog = 1 - Math.min(1, remaining / dur);\n          this.registry.set('reloadActive', true);\n          this.registry.set('reloadProgress', prog);\n        }\n      }\n    }\n\n    // Update UI registry for heat\n    this.registry.set('laserHeat', lz.heat);\n    this.registry.set('laserOverheated', !!lz.overheat);\n\n    // Draw and apply damage while firing and not overheated\n    lz.g.clear();\n    try { lz.mg.clear(); } catch (_) {}\n    if (canFire && !lz.overheat) {\n      const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, ptr.worldX, ptr.worldY);\n      // Start exactly at the barrel tip using weapon sprite + origin\n      const muzzle = getWeaponMuzzleWorld(this, 2);\n      const sx = muzzle.x;\n      const sy = muzzle.y;\n      const hit = this.computeLaserEnd(angle, sx, sy);\n      const ex = hit.ex, ey = hit.ey; const line = hit.line;\n      // Draw blue layered beam (player laser), under weapon layer\n      try {\n        lz.g.lineStyle(3, 0x66aaff, 0.95).beginPath(); lz.g.moveTo(sx, sy); lz.g.lineTo(ex, ey); lz.g.strokePath();\n        lz.g.lineStyle(1, 0xaaddff, 1).beginPath(); lz.g.moveTo(sx, sy - 1); lz.g.lineTo(ex, ey); lz.g.strokePath();\n      } catch (_) {}\n\n      // Laser muzzle twitch: larger white split rays (5) with subtle jitter\n      try {\n        const base = angle + Phaser.Math.DegToRad(Phaser.Math.Between(-3, 3));\n        const offs = [-28, -14, 0, 14, 28].map((d) => Phaser.Math.DegToRad(d + Phaser.Math.Between(-3, 3)));\n        for (let i = 0; i < offs.length; i += 1) {\n          const a = base + offs[i];\n          const len = 12 + (i === 2 ? 1 : 0);\n          const hx = sx + Math.cos(a) * len;\n          const hy = sy + Math.sin(a) * len;\n          const thick = (i === 2) ? 2 : 1;\n          lz.mg.lineStyle(thick, 0xffffff, 0.55).beginPath(); lz.mg.moveTo(sx, sy); lz.mg.lineTo(hx, hy); lz.mg.strokePath();\n        }\n        // smaller bloom at muzzle\n        lz.mg.fillStyle(0xffffff, 0.5).fillCircle(sx, sy, 1.5);\n      } catch (_) {}\n\n      // Shield block spark for laser (if recently blocked by a Rook)\n      try {\n        const lb = this._lastLaserBlockedAt;\n        if (lb && (now - lb.t) <= 50) {\n          impactBurst(this, lb.x, lb.y, { color: 0xff3333, size: 'small' });\n          this._lastLaserBlockedAt = null;\n        }\n      } catch (_) {}\n\n      // Damage ticking\n      lz.lastTickAt = (lz.lastTickAt || 0);\n      lz.lastTickAt += dt;\n      if (lz.lastTickAt >= tickRate) {\n        const step = lz.lastTickAt; lz.lastTickAt = 0;\n        const dps = 30; const ignitePerSec = 8;\n        const dmg = Math.max(0, Math.round(dps * step));\n        const igniteAdd = ignitePerSec * step;\n        // Only apply to the first hit enemy (no penetration)\n        const e = hit.hitEnemy;\n        if (e && e.active) {\n          // Hit VFX on enemy at contact point\n          try { impactBurst(this, ex, ey, { color: 0x66aaff, size: 'small' }); } catch (_) {}\n          if (e.isDummy) {\n            this._dummyDamage = (this._dummyDamage || 0) + dmg;\n          } else {\n            if (typeof e.hp !== 'number') e.hp = e.maxHp || 20;\n            e.hp -= dmg;\n            if (e.hp <= 0) { this.killEnemy(e); }\n          }\n          // Ignite buildup\n          e._igniteValue = Math.min(10, (e._igniteValue || 0) + igniteAdd);\n          if ((e._igniteValue || 0) >= 10) {\n            e._ignitedUntil = this.time.now + 2000;\n            e._igniteValue = 0; // reset on trigger\n            if (!e._igniteIndicator) {\n              e._igniteIndicator = this.add.graphics();\n              try { e._igniteIndicator.setDepth(9000); } catch (_) {}\n              e._igniteIndicator.fillStyle(0xff3333, 1).fillCircle(0, 0, 2);\n            }\n            try { e._igniteIndicator.setPosition(e.x, e.y - 14); } catch (_) {}\n          }\n        }\n      }\n    } else {\n      // not firing: clear beam and muzzle twitch\n      lz.g.clear();\n      try { lz.mg.clear(); } catch (_) {}\n    }\n  }\n\n  computeLaserEnd(angle, sxOverride = null, syOverride = null) {\n    // Ray from start point (weapon) towards angle; clip to nearest barricade\n    const maxLen = 1000;\n    const sx = (typeof sxOverride === 'number') ? sxOverride : this.player.x;\n    const sy = (typeof syOverride === 'number') ? syOverride : this.player.y;\n    const ex0 = sx + Math.cos(angle) * maxLen;\n    const ey0 = sy + Math.sin(angle) * maxLen;\n    const ray = new Phaser.Geom.Line(sx, sy, ex0, ey0);\n    let ex = ex0; let ey = ey0; let bestD2 = Infinity; let hitEnemy = null;\n    const testGroups = [this.barricadesHard, this.barricadesSoft];\n    for (let gi = 0; gi < testGroups.length; gi += 1) {\n      const g = testGroups[gi]; if (!g) continue;\n      const arr = g.getChildren?.() || [];\n      for (let i = 0; i < arr.length; i += 1) {\n        const s = arr[i]; if (!s?.active) continue;\n        const rect = s.getBounds?.() || new Phaser.Geom.Rectangle(s.x - 8, s.y - 8, 16, 16);\n        const pts = Phaser.Geom.Intersects.GetLineToRectangle(ray, rect);\n        if (pts && pts.length) {\n          const p = pts[0]; const dx = p.x - sx; const dy = p.y - sy; const d2 = dx * dx + dy * dy;\n          if (d2 < bestD2) { bestD2 = d2; ex = p.x; ey = p.y; }\n        }\n      }\n    }\n    // Also stop at first enemy before barricade; handle Rook shield as a blocker\n    const enemies = this.enemies?.getChildren?.() || [];\n    for (let i = 0; i < enemies.length; i += 1) {\n      const e = enemies[i]; if (!e?.active) continue;\n      // Rook shield: treat 90掳 arc as obstacle if facing the beam source\n      if (e.isRook) {\n        try {\n          const r = (e._shieldRadius || 60);\n          const gap = 35; const off = (gap - r);\n          const cx = e.x + Math.cos(e._shieldAngle || 0) * off;\n          const cy = e.y + Math.sin(e._shieldAngle || 0) * off;\n          const dirToSource = Math.atan2(sy - cy, sx - cx);\n          const shieldAng = e._shieldAngle || 0;\n          const diff = Math.abs(Phaser.Math.Angle.Wrap(dirToSource - shieldAng));\n          const half = Phaser.Math.DegToRad(45);\n          if (diff <= half) {\n            // Intersect ray with shield radius circle around Rook\n            // r from above\n            const dxr = Math.cos(angle), dyr = Math.sin(angle);\n            const fx = sx - cx, fy = sy - cy; // ray origin relative to shield center\n            const a = dxr * dxr + dyr * dyr;\n            const bq = 2 * (fx * dxr + fy * dyr);\n            const c = fx * fx + fy * fy - r * r;\n            const disc = bq * bq - 4 * a * c;\n            if (disc >= 0) {\n              const sqrtD = Math.sqrt(disc);\n              const t1 = (-bq - sqrtD) / (2 * a);\n              const t2 = (-bq + sqrtD) / (2 * a);\n              const t = (t1 > 0) ? t1 : ((t2 > 0) ? t2 : null);\n              if (t != null) {\n                const bx = sx + dxr * t; const by = sy + dyr * t;\n                const ddx = bx - sx; const ddy = by - sy; const d2 = ddx * ddx + ddy * ddy;\n                if (d2 < bestD2) {\n                  bestD2 = d2; ex = bx; ey = by; hitEnemy = null;\n                  this._lastLaserBlockedAt = { x: ex, y: ey, t: this.time.now };\n                }\n              }\n            }\n          }\n        } catch (_) {}\n      }\n      // Standard enemy rect hit if not blocked closer\n      const rect = e.getBounds?.() || new Phaser.Geom.Rectangle(e.x - 6, e.y - 6, 12, 12);\n      const pts = Phaser.Geom.Intersects.GetLineToRectangle(ray, rect);\n      if (pts && pts.length) {\n        const p = pts[0]; const dx = p.x - sx; const dy = p.y - sy; const d2 = dx * dx + dy * dy;\n        if (d2 < bestD2) { bestD2 = d2; ex = p.x; ey = p.y; hitEnemy = e; }\n      }\n    }\n    return { ex, ey, line: new Phaser.Geom.Line(sx, sy, ex, ey), hitEnemy };\n  }\n\n  // Spawn a temporary fire field that applies ignite to enemies inside\n  spawnFireField(x, y, radius, durationMs = 2000) {\n    if (!this._firefields) this._firefields = [];\n    // Additive glow\n    const g = this.add.graphics();\n    try { g.setDepth(7000); g.setBlendMode(Phaser.BlendModes.ADD); } catch (_) {}\n    // Rising embers via particles\n    let pm = null; let em = null;\n    try {\n      const texKey = 'fire_particle';\n      if (!this.textures || !this.textures.exists(texKey)) {\n        const tg = this.make.graphics({ x: 0, y: 0, add: false });\n        tg.clear();\n        tg.fillStyle(0xffdd66, 1).fillCircle(6, 6, 3);\n        tg.fillStyle(0xff9933, 0.9).fillCircle(6, 6, 5);\n        tg.fillStyle(0xff5522, 0.5).fillCircle(6, 6, 6);\n        tg.generateTexture(texKey, 12, 12);\n        tg.destroy();\n      }\n      pm = this.add.particles(texKey);\n      try { pm.setDepth(7050); } catch (_) {}\n      const zone = new Phaser.Geom.Circle(x, y, Math.max(6, Math.floor(radius * 0.85)));\n      em = pm.createEmitter({\n        emitZone: { type: 'random', source: zone },\n        frequency: 35,\n        quantity: 3,\n        lifespan: { min: 400, max: 900 },\n        speedY: { min: -70, max: -25 },\n        speedX: { min: -30, max: 30 },\n        alpha: { start: 0.95, end: 0 },\n        scale: { start: 0.9, end: 0 },\n        gravityY: -30,\n        tint: [0xffdd66, 0xffbb55, 0xff9933, 0xff5522],\n        blendMode: Phaser.BlendModes.ADD,\n      });\n    } catch (_) {}\n    // Initial draw\n    try {\n      g.clear();\n      const inner = Math.max(4, Math.floor(radius * 0.55));\n      g.fillStyle(0xff6622, 0.22).fillCircle(x, y, inner);\n      g.fillStyle(0xffaa33, 0.14).fillCircle(x, y, Math.floor(radius * 0.85));\n      g.lineStyle(2, 0xffaa33, 0.5).strokeCircle(x, y, radius);\n    } catch (_) {}\n    // Add an initial orange pixel spark burst (matches railgun/muzzle pixel effect)\n    try {\n      const bases = [0, Math.PI * 0.5, Math.PI, Math.PI * 1.5];\n      for (let i = 0; i < bases.length; i += 1) {\n        const base = bases[i] + Phaser.Math.FloatBetween(-0.2, 0.2);\n        pixelSparks(this, x, y, { angleRad: base, count: 6, spreadDeg: 38, speedMin: 80, speedMax: 160, lifeMs: 220, color: 0xffaa66, size: 2, alpha: 0.95 });\n      }\n    } catch (_) {}\n    const obj = { x, y, r: radius, until: this.time.now + durationMs, g, pm, em, _pulse: 0 };\n    this._firefields.push(obj);\n    return obj;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n